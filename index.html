<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Gobert 的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="音视频，流媒体开发者的博客，专业而不局限! 座右铭：不要低头，皇冠会掉；不要哭泣，贱人会笑！">
<meta property="og:type" content="website">
<meta property="og:title" content="Gobert 的博客">
<meta property="og:url" content="https://zzlc.github.io/index.html">
<meta property="og:site_name" content="Gobert 的博客">
<meta property="og:description" content="音视频，流媒体开发者的博客，专业而不局限! 座右铭：不要低头，皇冠会掉；不要哭泣，贱人会笑！">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gobert 的博客">
<meta name="twitter:description" content="音视频，流媒体开发者的博客，专业而不局限! 座右铭：不要低头，皇冠会掉；不要哭泣，贱人会笑！">
  
    <link rel="alternate" href="/atom.xml" title="Gobert 的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zzlc.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Gobert 的博客</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-WebRtc Windows develop patch 记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/12/WebRtc Windows develop patch 记录/" class="article-date">
  <time datetime="2018-09-11T22:13:22.000Z" itemprop="datePublished">2018-09-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/RTC/">RTC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/12/WebRtc Windows develop patch 记录/">WebRtc Windows develop patch 记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="1、WebRtc-源码升级-m63-gt-m68"><a href="#1、WebRtc-源码升级-m63-gt-m68" class="headerlink" title="1、WebRtc 源码升级 m63-&gt;m68"></a>1、WebRtc 源码升级 m63-&gt;m68</h2><p>升级过程中主要遇到两种编译问题：一是 webrtc 本身在同步、编译过程中有问题，另外就是在使用 <code>webrtc.lib</code> 时有报错；</p>
<ul>
<li>gclient sync  一直报：下载失败，或其他失败</li>
</ul>
<blockquote>
<p>这是因为 python 的缓冲中还留有部分旧版本的下载地址信息，导致下载失败，或者下载后版本不对应，删除当前用户目录下的 <code>.vpython_cipd_cache</code> 和 <code>.vpython-root</code>，然后再执行 <code>gclient sync</code> 即可;</p>
</blockquote>
<ul>
<li>SDK 编译链接时报无 <code>builtin_audio_decoder_factory</code> 相关符号</li>
</ul>
<blockquote>
<p>目前出现此问题的原因未知，不过 builtin_audio_decoder_factory 符号已编译，但 audio.lib（SDK 依赖 webrtc.lib, webrtc.lib 依赖 audio.lib）确没有把 builtin_audio_decoder_factory 符号包含进去，通过修改 <code>audio/BUILD.gn</code> 脚本，在其 line：58 添加一行依赖即可：<code>../api/audio_codecs:builtin_audio_decoder_factory</code></p>
</blockquote>
<h1 id="WebRtc-内部-Bug"><a href="#WebRtc-内部-Bug" class="headerlink" title="WebRtc 内部 Bug"></a>WebRtc 内部 Bug</h1><h2 id="Adm-创建失败，导致-crash"><a href="#Adm-创建失败，导致-crash" class="headerlink" title="Adm 创建失败，导致 crash"></a>Adm 创建失败，导致 crash</h2><blockquote>
<p>由于 webrtc 内部会对所有设备进行一下测试，有的设备可能测试是失败（但还是可以正常采集），测试失败的话，webrtc  默认会返回 false，导致创建的 adm 为 null，而其内部却没有对这种情况做兼容，导致 crash，修复方法：在 <code>modules/audio_device/win/audio_device_core_win.cc</code> 的 line：352 添加一行：<code>ok = 0;</code> ,即忽略测试失败的情况；</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzlc.github.io/2018/09/12/WebRtc Windows develop patch 记录/" data-id="cjr7fkklm00064ouv56ay6kwe" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WebRTC-windows/">WebRTC windows</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-WebRtc-源码分析之-rtc-Thread" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/30/WebRtc-源码分析之-rtc-Thread/" class="article-date">
  <time datetime="2018-03-29T22:13:22.000Z" itemprop="datePublished">2018-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/RTC/">RTC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/30/WebRtc-源码分析之-rtc-Thread/">WebRTC 源码阅读之 rtc::Thread</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <blockquote>
<p><code>rtc::Thread</code> 为 WebRTC内部实现的线程类，在 WebRTC中有广泛的应用，WebRTC内部 network thread、 worker thread、signal thread 等均要求为此线程类实例；</p>
<p>为了线程安全，在某些功能模块的使用上，有要求其必需在指定的线程中才能调用的基本要求，比如音频模块：ADM 的创建必须要在 WebRTC 的 worker thread 中进行。</p>
</blockquote>
<h2 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h2><p><code>rtc::Thread</code> 继承自消息队列<code>rtc::MessageQueue</code> ，内部提供了丰富的创建、管理接口，其借助于 <code>线程局部存储/线程局部静态变量</code> 实现线程的安全调用，以及是否是当前线程的有效判断。<br><img src="/images/线程.png" alt="rtc::Thread UML 类图"></p>
<h2 id="RTC-DISALLOW-COPY-AND-ASSIGN"><a href="#RTC-DISALLOW-COPY-AND-ASSIGN" class="headerlink" title="RTC_DISALLOW_COPY_AND_ASSIGN"></a>RTC_DISALLOW_COPY_AND_ASSIGN</h2><p><code>RTC_DISALLOW_COPY_AND_ASSIGN</code> 和 <code>RTC_DISALLOW_ASSIGN</code> 配合使用，通过禁用类的拷贝构造函数 和 <code>=</code> 操作符，提高代码的安全性。</p>
<h2 id="rtc-Thread-成员"><a href="#rtc-Thread-成员" class="headerlink" title="rtc::Thread 成员"></a>rtc::Thread 成员</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自此类的子类，必须在其析构中主动调用 Stop 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RTC_LOCKABLE</span> <span class="title">Thread</span> :</span> <span class="keyword">public</span> MessageQueue &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 已弃用的默认构造函数，不要使用，应该使用下面的静态方法进行创建类实例</span></span><br><span class="line">  <span class="comment">// 建议在开发过程中使用 CreateWithSocketServer 创建</span></span><br><span class="line">  Thread();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Thread</span><span class="params">(SocketServer* ss)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Thread</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SocketServer&gt; ss)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有的子类均必须保证在其析构函数中或者之前明确调用 Stop() 方法</span></span><br><span class="line">  <span class="comment">// 这样做是为了避免 Thread::PreRun 调用 Run() 方法时，析构函数对虚函数表的修改</span></span><br><span class="line">  ~Thread() override;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rtc::Thread 提供的创建类实例的静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Thread&gt; CreateWithSocketServer();</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Thread&gt; Create();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回当前线程的实例指针</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Thread* <span class="title">Current</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 单实例类，在 Thread 内部作为一个友元类，辅助 Thread 用于避免在指定的作用域中同步调用 Invoke 方法</span></span><br><span class="line">  <span class="comment">// 如果发生了同步方法的调用，则会触发一个断言</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ScopedDisallowBlockingCalls</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    ScopedDisallowBlockingCalls();</span><br><span class="line">    ~ScopedDisallowBlockingCalls();</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    Thread* <span class="keyword">const</span> thread_;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> previous_state_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断调用者所在线程是否处于本线程实例中</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsCurrent</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将线程睡眠指定的毫秒数，默认返回 true，除非被 POSIX 发送的信号终止，它才会返回 false</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">SleepMs</span><span class="params">(<span class="keyword">int</span> millis)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置线程名字，它必须在 调用 Start() 之前调用，这个方法是为了方便调试时查看</span></span><br><span class="line">  <span class="comment">// 如果 @param obj 为空，它将追加到 @param name 后面</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SetName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="keyword">void</span>* obj)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始执行此线程，如果 runnable 不为空，则运行其内部的 thread，否则启动本线程</span></span><br><span class="line">  <span class="comment">// 一般传入 nullptr，即表示启动线程实例本身</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Start</span><span class="params">(Runnable* runnable = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知线程结束，并阻塞等待；如果调用继承的 Quit 方法，则只会结束消息队列循环，而不会结束线程</span></span><br><span class="line">  <span class="comment">// 注意：一定不要在线程内部调用此方法    </span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认情况下，将调用 ProcessMessages(kForever),如果要做其它工作，则需要重写 Run()</span></span><br><span class="line">  <span class="comment">// 如果需要接受或者处理消息，则需要自己主动调用 ProcessMessages 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向消息队列发消息，并阻塞等待其执行完毕</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">(<span class="keyword">const</span> Location&amp; posted_from,</span></span></span><br><span class="line"><span class="function"><span class="params">                    MessageHandler* phandler,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">uint32_t</span> id = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    MessageData* pdata = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在其它线程保证某方法被此线程调用，相当于消息的异步通知，即 POST</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ReturnT</span>, <span class="title">class</span> <span class="title">FunctorT</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">ReturnT</span> <span class="title">Invoke</span>(<span class="title">const</span> <span class="title">Location</span>&amp; <span class="title">posted_from</span>, <span class="title">const</span> <span class="title">FunctorT</span>&amp; <span class="title">functor</span>) &#123;</span></span><br><span class="line">    FunctorMessageHandler&lt;ReturnT, FunctorT&gt; handler(functor);</span><br><span class="line">    InvokeInternal(posted_from, &amp;handler);</span><br><span class="line">    <span class="keyword">return</span> handler.MoveResult();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 继承与 MessageQueue</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">(MessageHandler* phandler,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">uint32_t</span> id = MQID_ANY,</span></span></span><br><span class="line"><span class="function"><span class="params">             MessageList* removed = <span class="literal">nullptr</span>)</span> override</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReceiveSends</span><span class="params">()</span> override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ProcessMessages will process I/O and dispatch messages until:</span></span><br><span class="line">  <span class="comment">//  1) cms milliseconds have elapsed (returns true)</span></span><br><span class="line">  <span class="comment">//  2) Stop() is called (returns false)</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ProcessMessages</span><span class="params">(<span class="keyword">int</span> cms)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断此线程是否是我们自己通过标准的构造函数进行创建的，如果是就返回 true</span></span><br><span class="line">  <span class="comment">// 如果是通过 ThreadManager::WrapCurrentThread() 创建的则返回 false</span></span><br><span class="line">  <span class="comment">// 不能对 IsOwned 返回 false 线程对象调用 Start</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsOwned</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取平台相关的线程句柄和 Id</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WEBRTC_WIN)</span></span><br><span class="line">  <span class="function">HANDLE <span class="title">GetHandle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> thread_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">DWORD <span class="title">GetId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> thread_id_;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(WEBRTC_POSIX)</span></span><br><span class="line">  <span class="keyword">pthread_t</span> GetPThread() &#123;</span><br><span class="line">    <span class="keyword">return</span> thread_;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Expose private method running() for tests.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// DANGER: this is a terrible public API.  Most callers that might want to</span></span><br><span class="line">  <span class="comment">// call this likely do not have enough control/knowledge of the Thread in</span></span><br><span class="line">  <span class="comment">// question to guarantee that the returned value remains true for the duration</span></span><br><span class="line">  <span class="comment">// of whatever code is conditionally executing because of the return value!</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">RunningForTest</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> running(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sets the per-thread allow-blocking-calls flag and returns the previous</span></span><br><span class="line">  <span class="comment">// value. Must be called on this thread.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SetAllowBlockingCalls</span><span class="params">(<span class="keyword">bool</span> allow)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// These functions are public to avoid injecting test hooks. Don't call them</span></span><br><span class="line">  <span class="comment">// outside of tests.</span></span><br><span class="line">  <span class="comment">// This method should be called when thread is created using non standard</span></span><br><span class="line">  <span class="comment">// method, like derived implementation of rtc::Thread and it can not be</span></span><br><span class="line">  <span class="comment">// started by calling Start(). This will set started flag to true and</span></span><br><span class="line">  <span class="comment">// owned to false. This must be called from the current thread.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">WrapCurrent</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">UnwrapCurrent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// Same as WrapCurrent except that it never fails as it does not try to</span></span><br><span class="line">  <span class="comment">// acquire the synchronization access of the thread. The caller should never</span></span><br><span class="line">  <span class="comment">// call Stop() or Join() on this thread.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SafeWrapCurrent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Blocks the calling thread until this thread has terminated.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Join</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AssertBlockingIsAllowedOnCurrentThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopedDisallowBlockingCalls</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ThreadInit</span> &#123;</span></span><br><span class="line">    Thread* thread;</span><br><span class="line">    Runnable* runnable;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WEBRTC_WIN)</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> DWORD WINAPI <span class="title">PreRun</span><span class="params">(LPVOID context)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">PreRun</span><span class="params">(<span class="keyword">void</span> *pv)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ThreadManager calls this instead WrapCurrent() because</span></span><br><span class="line">  <span class="comment">// ThreadManager::Instance() cannot be used while ThreadManager is</span></span><br><span class="line">  <span class="comment">// being created.</span></span><br><span class="line">  <span class="comment">// The method tries to get synchronization rights of the thread on Windows if</span></span><br><span class="line">  <span class="comment">// |need_synchronize_access| is true.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">WrapCurrentWithThreadManager</span><span class="params">(ThreadManager* thread_manager,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">bool</span> need_synchronize_access)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if the thread was started and hasn't yet stopped.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">running</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> running_.Wait(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Processes received "Send" requests. If |source| is not null, only requests</span></span><br><span class="line">  <span class="comment">// from |source| are processed, otherwise, all requests are processed.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReceiveSendsFromThread</span><span class="params">(<span class="keyword">const</span> Thread* source)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If |source| is not null, pops the first "Send" message from |source| in</span></span><br><span class="line">  <span class="comment">// |sendlist_|, otherwise, pops the first "Send" message of |sendlist_|.</span></span><br><span class="line">  <span class="comment">// The caller must lock |crit_| before calling.</span></span><br><span class="line">  <span class="comment">// Returns true if there is such a message.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">PopSendMessageFromThread</span><span class="params">(<span class="keyword">const</span> Thread* source, _SendMessage* msg)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">InvokeInternal</span><span class="params">(<span class="keyword">const</span> Location&amp; posted_from, MessageHandler* handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;_SendMessage&gt; sendlist_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">  Event running_;  <span class="comment">// Signalled means running.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WEBRTC_POSIX)</span></span><br><span class="line">  <span class="keyword">pthread_t</span> thread_;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WEBRTC_WIN)</span></span><br><span class="line">  HANDLE thread_;</span><br><span class="line">  DWORD thread_id_;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> owned_;</span><br><span class="line">  <span class="keyword">bool</span> blocking_calls_allowed_;  <span class="comment">// By default set to |true|.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadManager</span>;</span></span><br><span class="line"></span><br><span class="line">  RTC_DISALLOW_COPY_AND_ASSIGN(Thread);  <span class="comment">// 禁用拷贝构造和操作运算符 =</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><ul>
<li>创建实例</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;rtc::Thread&gt; _worker_thread_ptr(<span class="built_in">std</span>::move(rtc::Thread::CreateWithSocketServer()));</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;rtc::Thread&gt; _signal_thread_ptr(<span class="built_in">std</span>::move(rtc::Thread::CreateWithSocketServer()));</span><br><span class="line">_worker_thread_ptr-&gt;Start();</span><br><span class="line">_signal_thread_ptr-&gt;Start();</span><br><span class="line">......</span><br><span class="line">_worker_thread_ptr-&gt;Stop();</span><br><span class="line">_signal_thread_ptr-&gt;Stop();</span><br></pre></td></tr></table></figure>
<ul>
<li>创建音频模块 ADM</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rtc::scoped_refptr&lt;webrtc::AudioDeviceModule&gt; _adm_ptr =</span><br><span class="line">    _worker_thread_ptr-&gt;Invoke&lt;rtc::scoped_refptr&lt;webrtc::AudioDeviceModule&gt;&gt;(RTC_FROM_HERE, [] &#123;</span><br><span class="line">        <span class="comment">//create adm</span></span><br><span class="line">        <span class="keyword">return</span> webrtc::AudioDeviceModule::Create(<span class="number">0</span>,</span><br><span class="line">            webrtc::AudioDeviceModule::AudioLayer::kWindowsCoreAudio);</span><br><span class="line"> 	&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>创建 PC 工厂类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rtc::scoped_refptr&lt;webrtc::PeerConnectionFactoryInterface&gt; _peerconn_factory_ptr = 		webrtc::CreatePeerConnectionFactory(</span><br><span class="line">        _worker_thread_ptr.get(), _worker_thread_ptr.get(), _signal_thread_ptr.get(), _adm_ptr, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzlc.github.io/2018/03/30/WebRtc-源码分析之-rtc-Thread/" data-id="cjr7fkklt000a4ouvhx06pen3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WebRTC-Thread/">WebRTC::Thread</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Linux-常用命令备忘录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/22/Linux-常用命令备忘录/" class="article-date">
  <time datetime="2018-03-21T16:34:14.000Z" itemprop="datePublished">2018-03-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/经验总结/">经验总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/22/Linux-常用命令备忘录/">Linux 常用命令备忘录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <blockquote>
<p>记录 Linux 常用命令</p>
</blockquote>
<h2 id="常看实时网速"><a href="#常看实时网速" class="headerlink" title="常看实时网速"></a>常看实时网速</h2><pre><code>- nethogs: 按进程查看流量占用
- iptraf: 按连接/端口查看流量
- ifstat: 按设备查看流量
- ethtool: 诊断工具
- tcpdump: 抓包工具
- ss: 连接查看工具
其他: dstat, slurm, nload, bmon

简单的建议就是使用 ifstat，输入命令，直接就列出所有网卡的实时网速；
ss 命令可以查看当前所有的连接，类似 netstat，但是更加方便；
</code></pre><h2 id="screen-管理远程会话连接"><a href="#screen-管理远程会话连接" class="headerlink" title="screen 管理远程会话连接"></a>screen 管理远程会话连接</h2><p>###语法</p>
<h4 id="screen-AmRvx-ls-wipe-d-lt-作业名称-gt-h-lt-行数-gt-r-lt-作业名称-gt-s-S-lt-作业名称-gt"><a href="#screen-AmRvx-ls-wipe-d-lt-作业名称-gt-h-lt-行数-gt-r-lt-作业名称-gt-s-S-lt-作业名称-gt" class="headerlink" title="screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]"></a>screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]</h4><p>参数说明</p>
<p>-A 　将所有的视窗都调整为目前终端机的大小。</p>
<p>-d &lt;作业名称&gt; 　将指定的screen作业离线。</p>
<p>-h &lt;行数&gt; 　指定视窗的缓冲区行数。</p>
<p>-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。</p>
<p>-r &lt;作业名称&gt; 　恢复离线的screen作业。</p>
<p>-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。</p>
<p>-s 　指定建立新视窗时，所要执行的shell。</p>
<p>-S &lt;作业名称&gt; 　指定screen作业的名称。</p>
<p>-v 　显示版本信息。</p>
<p>-x 　恢复之前离线的screen作业。</p>
<p>-ls或–list 　显示目前所有的screen作业。</p>
<p>-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。</p>
<h3 id="常用screen参数"><a href="#常用screen参数" class="headerlink" title="常用screen参数"></a>常用screen参数</h3><p><a href="http://blog.csdn.net/zy_zhengyang/article/details/52385887" target="_blank" rel="noopener">参考网址</a></p>
<p>screen -S yourname -&gt; 新建一个叫yourname的session</p>
<p>screen -ls -&gt; 列出当前所有的session</p>
<p>screen -r yourname -&gt; 回到yourname这个session</p>
<p>screen -d yourname -&gt; 远程detach某个session</p>
<p>screen -d -r yourname -&gt; 结束当前session并回到yourname这个session</p>
<p>在每个screen session 下，所有命令都以 ctrl+a(C-a) 开始。</p>
<p>C-a ? -&gt; 显示所有键绑定信息</p>
<p>C-a c -&gt; 创建一个新的运行shell的窗口并切换到该窗口</p>
<p>C-a n -&gt; Next，切换到下一个 window </p>
<p>C-a p -&gt; Previous，切换到前一个 window </p>
<p>C-a 0..9 -&gt; 切换到第 0..9 个 window</p>
<p>Ctrl+a [Space] -&gt; 由视窗0循序切换到视窗9</p>
<p>C-a C-a -&gt; 在两个最近使用的 window 间切换 </p>
<p>C-a x -&gt; 锁住当前的 window，需用用户密码解锁</p>
<p>C-a d -&gt; detach，暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响。 </p>
<p>C-a z -&gt; 把当前session放到后台执行，用 shell 的 fg 命令则可回去。</p>
<p>C-a w -&gt; 显示所有窗口列表</p>
<p>C-a t -&gt; Time，显示当前时间，和系统的 load </p>
<p>C-a k -&gt; kill window，强行关闭当前的 window</p>
<p>C-a [ -&gt; 进入 copy mode，在 copy mode 下可以回滚、搜索、复制就像用使用 vi 一样</p>
<pre><code>C-b Backward，PageUp 

C-f Forward，PageDown 

H(大写) High，将光标移至左上角 

L Low，将光标移至左下角 

0 移到行首 

$ 行末 

w forward one word，以字为单位往前移 

b backward one word，以字为单位往后移 

Space 第一次按为标记区起点，第二次按为终点 

Esc 结束 copy mode 
</code></pre><p>C-a ] -&gt; Paste，把刚刚在 copy mode 选定的内容贴上</p>
<h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>查看系统配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure></p>
<p>查看当前用户 Git 配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure></p>
<p>查看当前仓库配置信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list</span><br></pre></td></tr></table></figure></p>
<p>配置用户名密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;myname&quot;</span><br><span class="line">git config --global user.email  &quot;test@gmail.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>生成 ssh key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>public key 文件为 ：<code>~/.ssh/id_rsa.pub</code>；</p>
<p>添加到 github 的 ssh key 中后，测试命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T ssh@github.com</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzlc.github.io/2018/03/22/Linux-常用命令备忘录/" data-id="cjr7fkklp00084ouv0rlhe3j8" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-解决-WebRTC-花屏问题记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/19/解决-WebRTC-花屏问题记录/" class="article-date">
  <time datetime="2018-03-19T14:46:34.000Z" itemprop="datePublished">2018-03-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/RTC/">RTC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/19/解决-WebRTC-花屏问题记录/">解决 WebRTC 花屏问题记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <blockquote>
<p>现象：WebRTC native 层经常打印 <code>Failed to unprotect SRTP packet, err=9</code>，订阅端会出现部分绿屏、花屏的情况，严重影响视频通话体验。</p>
</blockquote>
<h1 id="情景描述"><a href="#情景描述" class="headerlink" title="情景描述"></a>情景描述</h1><p>当前基于 WebRTC 开发自己的音视频实时通话的产品，服务器选择了 licode，在多端 H5、Android、iOS、C++ Native 端均有一定的概率会出现绿屏、花屏的现象，特别是在弱网下出现的概率更高；</p>
<p>在出现绿屏、花屏时，native log 也会经常输出的 <code>Failed to unprotect SRTP packet, err=9</code> log，花屏时，或者完全无法播放（有流量，但无画面），此 <code>Failed to unprotect SRTP packet, err=9</code> log 出现的概率更高；</p>
<p>当前已排除不同订阅终端在同一房间内跨运营商的网络问题，但依然会存在此类问题；</p>
<p>RTP/RTCP</p>
<ul>
<li><p>SR（Sender Report） 发送端报告</p>
</li>
<li><p>RR（Receiver Report）接收端报告</p>
</li>
<li><p>REMB (Receiver Estimated Maximum Bitrate)</p>
<p>接收端最大接收码率估测，接收端会估计本地接收的最大带宽能力，并通过RTCP REMB 消息返回给对端，这样对端可以调整自己的发送端码率，达到动态调整带宽的目的，具体消息类型通过rtcp的属性 <code>Unique identifier</code> 来区分是 <code>REMG</code> 消息，此部分是四个字节，</p>
</li>
</ul>
<p>REMG 信令协商：webrtc里面的协商格式是：<code>a=rtcp-fb:100 goog-remb，100 是codec payload</code>; 这里goog 实际上是 google 实现了自己版本的remb。</p>
<ul>
<li><p>GCC 码率估计算法（接收端），用来生成 <code>REMG</code> 包</p>
</li>
<li><p>TMMBR（Temporal Max Media Bitrate Request），表示临时最大码率请求。表明接收端当前带宽受限，告诉发送端控制码率。</p>
</li>
<li><p>TMMBN（Temporal Max Media Bitrate Notification）临时最大码率通知。</p>
</li>
<li><p>SDES 源描述，主要功能是作为会话成员有关标识信息的载体，如用户名、邮件地址、电话号码等，此外还具有向会话成员传达会话控制信息的功能。</p>
</li>
<li><p>BYE　通知离开，主要功能是指示某一个或者几个源不再有效，即通知会话中的其他成员自己将退出会话。</p>
</li>
<li><p>APP　由应用程序自己定义，解决了RTCP的扩展性问题，并且为协议的实现者提供了很大的灵活性。</p>
</li>
</ul>
<p><strong>关键帧请求</strong></p>
<ul>
<li><p>PLI（Picture Loss Indication）</p>
</li>
<li><p>SLI（Slice Loss Indication）</p>
</li>
</ul>
<p>发送方接收到接收方反馈的PLI或SLI需要重新让编码器生成关键帧并发送给接收端。</p>
<ul>
<li>FIR（Full Intra Request）</li>
</ul>
<p>这里面 Intra 的含义是图像内编码，不需要其他图像信息即可解码；Inter 指图像间编码，解码需要参考帧。所以 Intra Frame 其实就是指 I 帧，Inter Frame指 P 帧或 B 帧。</p>
<blockquote>
<p>那么为什么在 PLI 和 SLI 之外还需要一个 FIR 呢？<br>原因是使用场景不同，FIR 更多是在一个中心化的 Video Conference 中，新的参与者加入，就需要发送一个 FIR，其他的参与者给他发送一个关键帧这样才能解码，而 PLI 和 SLI 的含义更多是在发生丢包或解码错误时使用。</p>
</blockquote>
<p><strong>重传请求</strong></p>
<ul>
<li>RTX／NACK／RPSI</li>
</ul>
<p>这个重传跟关键帧请求的区别是它可以要求任意帧进行重传;</p>
<ul>
<li><p>RED（redundant packet）冗余包，配合 FEC 使用。</p>
</li>
<li><p>FEC 前向纠错算法，经 FEC 算法计算后，通过 RED 生成冗余包。</p>
</li>
<li><p>SRTP 详解 <a href="http://blog.csdn.net/ljinddlj/article/details/3912747" target="_blank" rel="noopener">参考 ULR</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzlc.github.io/2018/03/19/解决-WebRTC-花屏问题记录/" data-id="cjr7fkkmf000n4ouv5yinxqh0" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-BOOST-在-Windows-下通过-VS-进行编译" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/12/BOOST-在-Windows-下通过-VS-进行编译/" class="article-date">
  <time datetime="2018-03-12T06:19:16.000Z" itemprop="datePublished">2018-03-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/12/BOOST-在-Windows-下通过-VS-进行编译/">BOOST 在 Windows 下通过 VS 进行编译</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="下载-Boost-源码"><a href="#下载-Boost-源码" class="headerlink" title="下载 Boost 源码"></a>下载 Boost 源码</h1><p>从官方下载 Boost 源码，之前用的一直是 boost 1.58.0，今天去官方网站看到最新的已经是 boost 1.66.0，最新版本的下载地址是：<a href="https://akamai.bintray.com/59/596389389c005814ecb2a6b64c31dccd2c3e6fbc5a802b4dfada999ae5844628?__gda__=exp=1520835412~hmac=6d6c97450b9b0b9421f696c922c483f87493fe9a10890fc7235a1c30c120f8e1&amp;response-content-disposition=attachment%3Bfilename%3D%22boost_1_66_0.7z%22&amp;response-content-type=application%2Fx-7z-compressed&amp;requestInfo=U2FsdGVkX19TK62uO_jw5nC8JAtKkRu4cX28_lg3Z3y4xQkcbs9DqFSaTA0PDQKfCQ9Q94pRYGu60LzIyLyeN5mNvuokt1GI_MdVPpMBQLpNhTWhePsfBOrGtyhg6MOCF0JFr3mSugB0Sihk9fO5Wr1BR4MLQS9n78rtxF7JwNmR7sZ6on6X6jtu9UTYTMBy&amp;response-X-Checksum-Sha1=075d0b43980614054b1f1bafd189f863bba6600e&amp;response-X-Checksum-Sha2=596389389c005814ecb2a6b64c31dccd2c3e6fbc5a802b4dfada999ae5844628" target="_blank" rel="noopener">下载地址</a></p>
<p>建议使用迅雷进行下载，通过浏览器下的比较慢。<br>下载后解压到自己的开源项目目录下，如：<code>E:\OpenSource\boost_1_66_0</code></p>
<h1 id="Windows-下通过-Visual-Studio-2015-编译"><a href="#Windows-下通过-Visual-Studio-2015-编译" class="headerlink" title="Windows 下通过 Visual Studio 2015 编译"></a>Windows 下通过 Visual Studio 2015 编译</h1><p>启动 VS2015 的 X86 本机工具命令提示符，即 <code>VS2015 x86 Native Tools Command Prompt</code> ，进入 boost 源码目录：<code>E:\OpenSource\boost_1_66_0</code>，然后执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.bat   //首先执行此命令生成 b2 编译工具</span><br><span class="line">bjam stage --toolset=msvc-14.0 --without-graph --without-graph_parallel --stagedir=&quot;D:\boost\boost_1_63_0\bin\vc14&quot; link=static runtime-link=static runtime-link=static threading=multi debug release</span><br></pre></td></tr></table></figure>
<p>以上命令生成 32bit 静态库；如果希望生成 64bit，则使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bjam stage --toolset=msvc-14.0 architecture=x86 address-model=64 --without-graph --without-graph_parallel --stagedir=&quot;D:\boost\boost_1_63_0\bin\vc14-x64&quot; link=static runtime-link=static runtime-link=static threading=multi debug release</span><br></pre></td></tr></table></figure></p>
<h1 id="相关编译选项"><a href="#相关编译选项" class="headerlink" title="相关编译选项"></a>相关编译选项</h1><p>下面详细解释一下每个参数的含义：</p>
<ul>
<li><p>stage/install：<br>stage表示只生成库（dll和lib），install还会生成包含头文件的include目录。本人推荐使用stage，因为install生成的这个include目录实际就是boost安装包解压缩后的boost目录（<code>E:\OpenSource\boost_1_66_0\boost</code>，只比include目录多几个非hpp文件，都很小），所以可以直接使用，而且不同的IDE都可以使用同一套头文件，这样既节省编译时间，也节省硬盘空间。</p>
</li>
<li><p>toolset：<br>指定编译器，可选的如borland、gcc、msvc（VC6）、msvc-14.0（VS2015）等。</p>
</li>
<li><p>without/with：<br>选择不编译/编译哪些库。因为python、mpi等库我都用不着，所以排除之。还有wave、graph、math、regex、test、program_options、serialization、signals这几个库编出的静态lib都非常大，所以不需要的也可以without掉。这可以根据各人需要进行选择，默认是全部编译。但是需要注意，如果选择编译python的话，是需要python语言支持的，应该到 python <a href="http://www.python.org/" target="_blank" rel="noopener">官方主页</a>下载安装。查看boost包含库的命令是bjam –show-libraries。</p>
</li>
<li><p>stagedir/prefix：<br>stage时使用stagedir，install时使用prefix，表示编译生成文件的路径。推荐给不同的IDE指定不同的目录。</p>
</li>
<li><p>build-dir：编译生成的中间文件的路径。这个本人这里没用到，默认就在根目录（<code>E:\OpenSource\boost_1_66_0</code>）下，目录名为bin.v2，等编译完成后可将这个目录全部删除（没用了），所以不需要去设置。</p>
</li>
<li><p>link：<br>生成动态链接库/静态链接库。生成动态链接库需使用shared方式，生成静态链接库需使用static方式。一般boost库可能都是以static方式编译，因为最终发布程序带着boost的dll感觉会比较累赘。</p>
</li>
<li><p>runtime-link：<br>动态/静态链接C/C++运行时库。同样有shared和static两种方式，这样runtime-link和link一共可以产生4种组合方式，各人可以根据自己的需要选择编译。一般link只选static的话，只需要编译2种组合即可，即link=static runtime-link=shared和link=static runtime-link=static，本人一般就编这两种组合。</p>
</li>
<li><p>threading：<br>单/多线程编译。一般都写多线程程序，当然要指定multi方式了；如果需要编写单线程程序，那么还需要编译单线程库，可以使用single方式。</p>
</li>
<li><p>debug/release：<br>编译debug/release版本。一般都是程序的debug版本对应库的debug版本，所以两个都编译。</p>
</li>
<li><p>address-model=32/64<br>寻址模式(生成32位还是64位库)</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzlc.github.io/2018/03/12/BOOST-在-Windows-下通过-VS-进行编译/" data-id="cjr7fkkla00024ouv56oq10ek" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-C-开源日志库-spdlog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/02/C-开源日志库-spdlog/" class="article-date">
  <time datetime="2018-03-01T16:04:36.000Z" itemprop="datePublished">2018-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/02/C-开源日志库-spdlog/">C++ 开源日志库 spdlog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="C-日志组件-spdlog"><a href="#C-日志组件-spdlog" class="headerlink" title="C++日志组件 spdlog"></a>C++日志组件 spdlog</h1><p><code>spdlog</code> 是基于C++ 11的开源的轻量级的日志组件，引入也非常简单，仅仅需要引入头文件就可以了。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>命名空间 <code>spdlog</code> 之下的大多数函数都是线程安全的，除了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> spdlog::set_pattern(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br><span class="line"><span class="keyword">void</span> spdlog::set_formatter(formatter_ptr);</span><br><span class="line"><span class="keyword">void</span> spdlog::set_error_handler(log_err_handler);</span><br></pre></td></tr></table></figure></p>
<p>日志器对象的大部分方法也是线程安全的，除了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> spdlog::logger::set_pattern(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br><span class="line"><span class="keyword">void</span> spdlog::logger::set_formatter(formatter_ptr);</span><br><span class="line"><span class="keyword">void</span> spdlog::set_error_handler(log_err_handler);</span><br></pre></td></tr></table></figure></p>
<p>所有以 <code>_mt</code> 结尾的 Sink 都是用于多线程的，以 <code>_st</code> 结尾的则是用于单线程的，不过现在单线程的程序很少了吧，建议直接用以 <code>_mt</code> 结尾的多线程安全的日志对象；</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"spdlog/spdlog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 多线程的基于控制台（stdout）的日志记录器，支持高亮。类似的stdout_color_st是单线程版本</span></span><br><span class="line"><span class="keyword">auto</span> console = spdlog::stdout_color_mt( <span class="string">"console"</span> );</span><br><span class="line"><span class="comment">// 基于文件的简单日志</span></span><br><span class="line"><span class="keyword">auto</span> logger = spdlog::basic_logger_mt(<span class="string">"basic_logger"</span>, <span class="string">"logs/basic.txt"</span>);</span><br><span class="line"><span class="comment">// 基于滚动文件的日志，每个文件5MB，三个文件</span></span><br><span class="line"><span class="keyword">auto</span> logger = spdlog::rotating_logger_mt(<span class="string">"file_logger"</span>, <span class="string">"myfilename"</span>, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定制输出格式</span></span><br><span class="line">spdlog::set_pattern(<span class="string">"*** [%H:%M:%S %z] [thread %t] %v ***"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 多个日志器共享SINK</span></span><br><span class="line"><span class="keyword">auto</span> daily_sink = <span class="built_in">std</span>::make_shared&lt;spdlog::sinks::daily_file_sink_mt&gt;(<span class="string">"logfile"</span>, <span class="number">23</span>, <span class="number">59</span>);</span><br><span class="line"><span class="comment">// 下面几个同步日志器共享的输出到目标文件</span></span><br><span class="line"><span class="keyword">auto</span> net_logger = <span class="built_in">std</span>::make_shared&lt;spdlog::logger&gt;(<span class="string">"net"</span>, daily_sink);</span><br><span class="line"><span class="keyword">auto</span> hw_logger = <span class="built_in">std</span>::make_shared&lt;spdlog::logger&gt;(<span class="string">"hw"</span>, daily_sink);</span><br><span class="line"><span class="keyword">auto</span> db_logger = <span class="built_in">std</span>::make_shared&lt;spdlog::logger&gt;(<span class="string">"db"</span>, daily_sink); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 一个日志器使用多个SINK</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;spdlog::sink_ptr&gt; sinks;</span><br><span class="line">sinks.push_back( <span class="built_in">std</span>::make_shared&lt;spdlog::sinks::stdout_sink_st&gt;());</span><br><span class="line">sinks.push_back( <span class="built_in">std</span>::make_shared&lt;spdlog::sinks::daily_file_sink_st&gt;( <span class="string">"logfile"</span>, <span class="number">23</span>, <span class="number">59</span> ));</span><br><span class="line"><span class="keyword">auto</span> combined_logger = <span class="built_in">std</span>::make_shared&lt;spdlog::logger&gt;( <span class="string">"name"</span>, begin( sinks ), end( sinks ));</span><br><span class="line">spdlog::register_logger( combined_logger );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line"><span class="comment">// 每个日志器分配8192长度的队列，队列长度必须2的幂</span></span><br><span class="line">spdlog::set_async_mode(<span class="number">8192</span>); </span><br><span class="line"><span class="comment">// 程序退出前清理</span></span><br><span class="line">spdlog::drop_all();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 注册日志器</span></span><br><span class="line">spdlog::register_logger(net_logger);</span><br><span class="line"><span class="comment">// 注册后，其它代码可以根据名称获得日志器</span></span><br><span class="line"><span class="keyword">auto</span> logger = spdlog::get(net_logger);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 记录日志</span></span><br><span class="line"><span class="comment">// 设置最低级别</span></span><br><span class="line">console-&gt;set_level(spdlog::level::debug);</span><br><span class="line">console-&gt;debug(<span class="string">"Hello World"</span>) ;</span><br><span class="line"><span class="comment">// 使用占位符</span></span><br><span class="line">console-&gt;info(<span class="string">"Hello &#123;&#125;"</span> ,<span class="string">"World"</span>); </span><br><span class="line"><span class="comment">// 带格式化的占位符：d整数，x十六进制，o八进制，b二进制                </span></span><br><span class="line">console-&gt;warn(<span class="string">"Support for int: &#123;0:d&#125;; hex: &#123;0:x&#125;; oct: &#123;0:o&#125;; bin: &#123;0:b&#125;"</span>, <span class="number">42</span>);</span><br><span class="line"><span class="comment">// 带格式化的占位符：f浮点数</span></span><br><span class="line">console-&gt;info(<span class="string">"Support for floats &#123;:03.2f&#125;"</span>, <span class="number">1.23456</span>);</span><br><span class="line"><span class="comment">// 左对齐，保证30字符宽度</span></span><br><span class="line">console-&gt;error(<span class="string">"&#123;:&lt;30&#125;"</span>, <span class="string">"left aligned"</span>);</span><br><span class="line"><span class="comment">// 指定占位符位置序号</span></span><br><span class="line">console-&gt;info(<span class="string">"Positional args are &#123;1&#125; &#123;0&#125;.."</span>, <span class="string">"too"</span>, <span class="string">"supported"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 记录自定义类型，需要重载&lt;&lt;操作符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;spdlog/fmt/ostr.h&gt; </span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>&#123;</span>&#125;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> Duck&amp; duck)&#123; </span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; duck.getName(); </span><br><span class="line">&#125;</span><br><span class="line">Duck duck;</span><br><span class="line">console-&gt;info(<span class="string">"custom class with operator&lt;&lt;: &#123;&#125;.."</span>, duck);</span><br></pre></td></tr></table></figure>
<p>输出格式</p>
<p>spdlog默认的输出格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2018-03-01 23:46:59.678] [info] [my_loggername] Some message</span><br></pre></td></tr></table></figure></p>
<p>要定制输出格式，可以调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//估计大部分人都喜欢下面这样的格式输出格式：</span></span><br><span class="line">spdlog::set_pattern(<span class="string">"[%Y-%m-%d %H:%M:%S.%e][%t][%l] %v"</span>);</span><br><span class="line"><span class="comment">//或者实现自己的格式化器：</span></span><br><span class="line">spdlog::set_formatter(<span class="built_in">std</span>::make_shared&lt;my_custom_formatter&gt;());</span><br></pre></td></tr></table></figure></p>
<p>输出格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2018-03-01 23:28:04.285][13464][info] Input host name:gobert, ptr:0x9c6a78</span><br></pre></td></tr></table></figure></p>
<p>Pattern 格式说明</p>
<p>输出格式的 Pattern 中可以有若干 <code>%</code> 开头的标记，含义如下表：</p>
<table>
<thead>
<tr>
<th>标记</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%v</td>
<td>实际需要被日志记录的文本，如果文本中有{占位符}会被替换</td>
</tr>
<tr>
<td>%t</td>
<td>线程标识符</td>
</tr>
<tr>
<td>%P</td>
<td>进程标识符</td>
</tr>
<tr>
<td>%n</td>
<td>日志记录器名称</td>
</tr>
<tr>
<td>%l</td>
<td>日志级别</td>
</tr>
<tr>
<td>%L</td>
<td>日志级别简写</td>
</tr>
<tr>
<td>%a</td>
<td>简写的周几，例如Thu</td>
</tr>
<tr>
<td>%A</td>
<td>周几，例如Thursday</td>
</tr>
<tr>
<td>%b</td>
<td>简写的月份，例如Aug</td>
</tr>
<tr>
<td>%B</td>
<td>月份，例如August</td>
</tr>
<tr>
<td>%c</td>
<td>日期时间，例如Thu Aug 23 15:35:46 2014</td>
</tr>
<tr>
<td>%C</td>
<td>两位年份，例如14</td>
</tr>
<tr>
<td>%Y</td>
<td>四位年份，例如2014</td>
</tr>
<tr>
<td>%D 或 %x</td>
<td>MM/DD/YY格式日期，例如”08/23/14</td>
</tr>
<tr>
<td>%m</td>
<td>月份，1-12之间</td>
</tr>
<tr>
<td>%d</td>
<td>月份中的第几天，1-31之间</td>
</tr>
<tr>
<td>%H</td>
<td>24小时制的小时，0-23之间</td>
</tr>
<tr>
<td>%I</td>
<td>12小时制的小时，1-12之间</td>
</tr>
<tr>
<td>%M</td>
<td>分钟，0-59</td>
</tr>
<tr>
<td>%S</td>
<td>秒，0-59</td>
</tr>
<tr>
<td>%e</td>
<td>当前秒内的毫秒，0-999</td>
</tr>
<tr>
<td>%f</td>
<td>当前秒内的微秒，0-999999</td>
</tr>
<tr>
<td>%F</td>
<td>当前秒内的纳秒， 0-999999999</td>
</tr>
<tr>
<td>%p</td>
<td>AM或者PM</td>
</tr>
<tr>
<td>%r</td>
<td>12小时时间，例如02:55:02 pm</td>
</tr>
<tr>
<td>%R</td>
<td>等价于%H:%M，例如23:55</td>
</tr>
<tr>
<td>%T 或 %X</td>
<td>HH:MM:SS</td>
</tr>
<tr>
<td>%z</td>
<td>时区UTC偏移，例如+02:00</td>
</tr>
<tr>
<td>%+</td>
<td>表示默认格式</td>
</tr>
</tbody>
</table>
<h2 id="个人实战应用源码"><a href="#个人实战应用源码" class="headerlink" title="个人实战应用源码"></a>个人实战应用源码</h2><p>根据个人的习惯，喜欢在开发后端程序时，喜欢将 log 同时输出到控制台和文件中，那么根据 spdlog 的接口，需要在创建对象时将 console 和 file sink 均传入即可，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spdlog::set_async_mode(<span class="number">4096</span>);</span><br><span class="line">spdlog::set_pattern(<span class="string">"[%Y-%m-%d %H:%M:%S.%e][%t][%l] %v"</span>);</span><br><span class="line"><span class="comment">//创建控制台对象指针</span></span><br><span class="line"><span class="keyword">auto</span> console_log_ptr = spdlog::stdout_logger_mt(<span class="string">"console"</span>);</span><br><span class="line"><span class="comment">//创建文件对象指针</span></span><br><span class="line"><span class="keyword">auto</span> file_log_ptr = spdlog::rotating_logger_mt(<span class="string">"file"</span>, <span class="string">"opc-collector.log"</span>, <span class="number">100</span> * <span class="number">1024</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//将以上两种日志对象 sink 组合在一起</span></span><br><span class="line">spdlog::sinks_init_list sink_list = &#123; console_log_ptr-&gt;sinks().front(), file_log_ptr-&gt;sinks().front() &#125;;</span><br><span class="line"><span class="comment">//创建一个新的日志对象，以上面两个日志对象作为初始化参数，即实现了同时输出 console 和 file</span></span><br><span class="line"><span class="keyword">auto</span> log_ptr = spdlog::create(<span class="string">"loggername"</span>, sink_list);</span><br><span class="line"></span><br><span class="line">log_ptr-&gt;info(<span class="string">"Test spdlog output:string:&#123;&#125;, int:&#123;&#125;"</span>, <span class="string">"spdlog info test string"</span>, <span class="number">123456</span>);</span><br><span class="line">log_ptr-&gt;flush();</span><br></pre></td></tr></table></figure>
<p><strong>注：将多个日志对象同时输出到一个日志对象时，其 loggername 不能保持一致，否则报错警告称：loggername 重复！</strong></p>
<p>以上内容大部分参考自：<a href="https://blog.gmem.cc/spdlog" target="_blank" rel="noopener">https://blog.gmem.cc/spdlog</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzlc.github.io/2018/03/02/C-开源日志库-spdlog/" data-id="cjr7fkklk00054ouvi8rgl1kt" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-Windows-10-安装-NetFrameWork-3-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/26/Windows-10-安装-NetFrameWork-3-5/" class="article-date">
  <time datetime="2018-02-26T06:05:19.000Z" itemprop="datePublished">2018-02-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OPC/">OPC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/26/Windows-10-安装-NetFrameWork-3-5/">Windows 10 安装 .NetFrameWork 3.5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="Windows-10-下安装-NetFrameWork-3-5"><a href="#Windows-10-下安装-NetFrameWork-3-5" class="headerlink" title="Windows 10 下安装 .NetFrameWork 3.5"></a>Windows 10 下安装 .NetFrameWork 3.5</h1><p>某些软件依赖.NetFrameWork 3.5,但是通过系统自带的 <code>启动或关闭 Windows 功能</code>的界面接口去添加 .NetFrameWork 3.5 会失败，即使先删除了 .NetFrameWork 4.7 也是会失败，比如会报如下一些错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x800F0906</span><br><span class="line">0x800F081F</span><br><span class="line">0x800F0907</span><br><span class="line">0x800F0922</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>现总结如下安装方法;</p>
<h2 id="下载-NetFrameWork-3-5-离线安装包"><a href="#下载-NetFrameWork-3-5-离线安装包" class="headerlink" title="下载 .NetFrameWork 3.5 离线安装包"></a>下载 .NetFrameWork 3.5 离线安装包</h2><p><a href="https://d11.baidupcs.com/file/f035714091c087774ca76a254018be04?bkt=p3-000014508cb2b9cb0151cee0f9ed3c6b0021&amp;xcode=7cbd07a2b4f6f74a3477739bc86162007cbccbd369afad2e710b2321bcd8d2e5e4b423467a61eb46&amp;fid=2098421940-250528-207166886389709&amp;time=1519614793&amp;sign=FDTAXGERLQBHSKa-DCb740ccc5511e5e8fedcff06b081203-kspSbRcHERbGt4GGM8ncJm%2B0M%2F8%3D&amp;to=d11&amp;size=72329390&amp;sta_dx=72329390&amp;sta_cs=70095&amp;sta_ft=cab&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CYangquan%2CAnywhere%2C%2Cshanghai%2Cct&amp;vuk=282335&amp;iv=0&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=000014508cb2b9cb0151cee0f9ed3c6b0021&amp;sl=79364174&amp;expires=8h&amp;rt=sh&amp;r=512254481&amp;mlogid=1309641164889007677&amp;vbdid=2429812664&amp;fin=NetFx3.cab&amp;fn=NetFx3.cab&amp;rtype=1&amp;dp-logid=1309641164889007677&amp;dp-callid=0.1.1&amp;hps=1&amp;tsl=100&amp;csl=100&amp;csign=azJdY%2B10Z49b0LbASthGmxMFU9c%3D&amp;so=0&amp;ut=6&amp;uter=4&amp;serv=0&amp;uc=1415919733&amp;ic=69126377&amp;ti=f8fdaa4589ff2f184c4630f76c465917b1fcaab7023e5652&amp;by=themis" target="_blank" rel="noopener">下载地址</a></p>
<p>下载完成后，将此文件 <code>NetFx3.cab</code> 不要解压直接拷贝到 <code>C:/Windows</code> 目录下;</p>
<h2 id="命令安装"><a href="#命令安装" class="headerlink" title="命令安装"></a>命令安装</h2><p>以管理员权限运行 cmd 命令，执行以下命令直至 100% 成功即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:netfx3 /Source:L:\sources\sxs</span><br></pre></td></tr></table></figure></p>
<h2 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h2><p>如果不出问题的话是可以安装成功的，且不用重启，这时打开控制面板中 <code>启动或关闭 Windows 功能</code> 的界面，可以看到 <code>.Net FrameWork 3.5</code> 已经安装成功了，这时勾选 <code>.Net FrameWork 4.7</code> 并确定，以免其它已安装的依赖软件不能正常运行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzlc.github.io/2018/02/26/Windows-10-安装-NetFrameWork-3-5/" data-id="cjr7fkkm1000e4ouvk29rdgco" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-Win10 开发部署 XP 或 Server 2003 的应用程序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/22/Win10 开发部署 XP 或 Server 2003 的应用程序/" class="article-date">
  <time datetime="2018-02-22T03:47:18.000Z" itemprop="datePublished">2018-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OPC/">OPC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/22/Win10 开发部署 XP 或 Server 2003 的应用程序/">Windows 10 开发部署支持 Windows XP 和 Windows Server 2003 的应用程序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>在 Windows 10 下通过 VS2015 开发的桌面程序，部署到 Windows Server 2003 系统中，运行不起来，运行会报 “不是有效的 Win32 应用程序” 或者是 “不能定位 XXX.XXX 到 api-ms-win-…-…-l1-1-0.dll”，这里原因有两个，一个是在编译时默认指定的平台工具集系统版本较高，另一个就是编译时依赖了只有 Windows Vista 以上版本的系统才支持的 UCRT 动态库，对此，只要按照以下方法重新编译下，即可解决低版本系统下运行的问题。</p>
<h1 id="解决低版本系统报错：-“不是有效的-Win32-应用程序”"><a href="#解决低版本系统报错：-“不是有效的-Win32-应用程序”" class="headerlink" title="解决低版本系统报错： “不是有效的 Win32 应用程序”"></a>解决低版本系统报错： “不是有效的 Win32 应用程序”</h1><p>将工程的平台工具集即 <code>Platform Toolset</code> 由 <code>Visual Studio 2015 (v140)</code> 改为 <code>Visual Studio 2015 - Windows XP (v140_xp)</code>；</p>
<p>重新编译后，通过 ExeScope 依次查看 <code>头部</code>–<code>可选头部</code>–<code>操作系统主版本</code> 发现其值为 0005，即说明该目标文件可以运行在 Windows version 为 5.0 以上的系统中了。</p>
<h1 id="解决-“无法定位…到-ucrt-库”"><a href="#解决-“无法定位…到-ucrt-库”" class="headerlink" title="解决 “无法定位…到 ucrt 库”"></a>解决 “无法定位…到 ucrt 库”</h1><p>VC++ 需要去除通用 CRT（UCRT）库的依赖。</p>
<h2 id="什么是-UCRT-库"><a href="#什么是-UCRT-库" class="headerlink" title="什么是 UCRT 库"></a>什么是 UCRT 库</h2><p>首先介绍下什么是 CRT 库：</p>
<p><code>C 运行时库 (CRT) 是集成了 ISO C99 标准库的 C++ 标准库。 实现 CRT 的 Visual C++ 库支持用于 .NET 开发的本机代码开发、本机和托管混合代码以及纯托管代码。 所有版本的 CRT 都支持多线程开发。 大多数的库都支持通过静态链接将库直接链接到代码中，或通过动态链接让代码使用常用 DLL 文件。</code></p>
<p>UCRT（通用 CRT） 包含通过标准 C99 CRT 库导出的函数和全局函数。 UCRT 现为 Windows 组件，并作为 Windows 10 的一部分提供。 静态库、DLL 导入库和 UCRT 的头文件现在 Windows 10 SDK 中提供。 安装 Visual C++ 时，Visual Studio 安装程序将安装使用 UCRT 所需 Windows 10 SDK 的子集。 可以在 Visual Studio 2015 支持的任何 Windows 版本上使用 UCRT。 可以使用 vcredist 重新分发它，以便支持 Windows 10 以外的 Windows 版本。</p>
<p>在 Visual Studio 2015 中，CRT 已重构为新的二进制文件。</p>
<p>Windows 下所有的 ucrt 库均存放在 <code>C:\Program Files (x86)\Windows Kits\10\Redist\ucrt</code> 目录下，而这些库是只有 Windows Vista 以上版本的系统才支持的，所以不能依赖此动态库，解决方法便是在编译程序时，将所有的工程的 <code>属性</code>–<code>C/C++</code>–<code>Code Generation</code>–<code>Runtime Library</code> 改为 <code>Multi-threaded (/MT)</code> 即可，重新编译后，通过 Stud_PE 查看其依赖项已经没有了 api 开发的 curt 动态库，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">api-ms-win-crt-runtime-l1-1-0.dll</span><br><span class="line">api-ms-win-crt-stdio-l1-1-0.dll</span><br><span class="line">api-ms-win-crt-math-l1-1-0.dll</span><br><span class="line">api-ms-win-crt-locale-l1-1-0.dll</span><br><span class="line">api-ms-win-crt-heap-l1-1-0.dll</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：这里是可以将工程的运行时库编译选项改为 MT 的情况下，如果你的工程不能改为 MT 那就只能将 UCRT 库全部带上了，但是如果是 UCRT 的动态库的话，是不支持 Windows XP 和 Server 2003 一下版本的系统的！</strong></p>
<p>关于 CRT 库的更多的介绍，请参考微软官方的文档：<a href="https://msdn.microsoft.com/zh-cn/library/abx4dbyh.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/abx4dbyh.aspx</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzlc.github.io/2018/02/22/Win10 开发部署 XP 或 Server 2003 的应用程序/" data-id="cjr7fkklx000d4ouvem964jr5" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-GitHub-博客搭建记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/29/GitHub-博客搭建记录/" class="article-date">
  <time datetime="2018-01-29T01:24:07.000Z" itemprop="datePublished">2018-01-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Life/">Life</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/29/GitHub-博客搭建记录/">GitHub 博客搭建记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <blockquote>
<ul>
<li>博客搭建记录</li>
<li>MarkDown 如何生成文章目录</li>
<li>创建分类页面</li>
<li>评论管理</li>
</ul>
</blockquote>
<h1 id="博客搭建记录"><a href="#博客搭建记录" class="headerlink" title="博客搭建记录"></a>博客搭建记录</h1><p>本文主要用于记录本博客在搭建过程中的一些细节，以免忘记！内容、格式较混乱。</p>
<h1 id="MarkDown-如何生成文章目录"><a href="#MarkDown-如何生成文章目录" class="headerlink" title="MarkDown 如何生成文章目录"></a>MarkDown 如何生成文章目录</h1><p>在段落中填写 <code>[TOC]</code> 既可显示全文内容的目录结构。</p>
<p><a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C" target="_blank" rel="noopener">Markdown 语法手册</a></p>
<p>本博客不支持 <code>TOC</code>。。。。</p>
<h1 id="创建分类页面"><a href="#创建分类页面" class="headerlink" title="创建分类页面"></a>创建分类页面</h1><p>添加一个 分类 页面，并在菜单中显示页面链接：</p>
<ul>
<li><p>新建一个页面，命名为 categories 。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑刚新建的页面，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2018-1-28 12:39:04</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>在菜单中添加链接。编辑主题的 _config.yml ，menu 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Menus</span><br><span class="line">menu:</span><br><span class="line">Home: /</span><br><span class="line"># Delete this row if you don&apos;t want categories in your header nav bar</span><br><span class="line">#archives: /archives</span><br><span class="line">#tags: /tags</span><br><span class="line">Categories: /categories</span><br><span class="line">About: /about/index.html</span><br></pre></td></tr></table></figure>
</li>
<li><p>将文章分类<br>新建文章后，在开头字段添加 categories: Life，其中 Life 就是我的分类类别，相同的 categories 博客会自动将其归类到一起，而且每一个类别均会显示在页面的 Header 中；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 2018 目标</span><br><span class="line">date: 2018-01-28 15:50:35</span><br><span class="line">tags:</span><br><span class="line">categories: Life</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="评论管理"><a href="#评论管理" class="headerlink" title="评论管理"></a>评论管理</h1><h2 id="开启或关闭评论"><a href="#开启或关闭评论" class="headerlink" title="开启或关闭评论"></a>开启或关闭评论</h2><p>如果有启用、或者关闭评论，默认页面也会带有评论。需要关闭的话，目前是在每一篇文章的开头添加字段 comments 并将值设置为 false（默认为开启），如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 2018 目标</span><br><span class="line">date: 2018-01-28 15:50:35</span><br><span class="line">tags:</span><br><span class="line">categories: Life</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure></p>
<p><strong>注：当下的这种方式比较愚，需要在每一篇文章的开头手动添加这个字段，后面再研究下如何在模板中自动将 comments 改为 false。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzlc.github.io/2018/01/29/GitHub-博客搭建记录/" data-id="cjr7fkklg00044ouv1ygjf7xi" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-Windows-下编译-WebRTC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/28/Windows-下编译-WebRTC/" class="article-date">
  <time datetime="2018-01-28T15:58:14.000Z" itemprop="datePublished">2018-01-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/RTC/">RTC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/28/Windows-下编译-WebRTC/">Windows 下编译 WebRTC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>– Windows 下编译 WebRTC</p>
<h1 id="一、系统环境准备"><a href="#一、系统环境准备" class="headerlink" title="一、系统环境准备"></a>一、系统环境准备</h1><h2 id="1、参考官方文档"><a href="#1、参考官方文档" class="headerlink" title="1、参考官方文档"></a>1、参考官方文档</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://webrtc.org/native-code/development/   //官方编译指导首页</span><br><span class="line">https://webrtc.org/native-code/development/prerequisite-sw/  //依赖工具安装指导页</span><br><span class="line">http://dev.chromium.org/developers/how-tos/install-depot-tools //用于下载代码的工具包安装指导页面</span><br></pre></td></tr></table></figure>
<h2 id="2、Windows-10-amp-MingW-amp-VS2015"><a href="#2、Windows-10-amp-MingW-amp-VS2015" class="headerlink" title="2、Windows 10 &amp; MingW &amp; VS2015"></a>2、Windows 10 &amp; MingW &amp; VS2015</h2><p>如果已经安装了 cygwin，则建议先将其重命名为 cygwin_bak，使其目录内的工具无效，因为 WebRTC 官方文档已经明确不推荐使用 CygWin 了，否则编译过程中可能会发生各种奇奇怪怪的错误，原文如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chromium is mostly designed to be run using the native Windows tools and the Msys (Git for Windows) toolchain. Cygwin is not recommended, and likely things will fail in cryptic ways.</span><br></pre></td></tr></table></figure>
<p>自行下载并安装 MingW。</p>
<p>自行下载安装 VS2015，因为最新的 webrtc 使用到了 C++ 11的一些新特性，如果使用 VS2013 等较旧的一些 IDE，可能会由于 对 C++ 11 支持的不够完整，而产生编译错误。</p>
<h2 id="3、安装-python"><a href="#3、安装-python" class="headerlink" title="3、安装 python"></a>3、安装 python</h2><p>下载并安装 python，并将其目录配置在环境变量中，一定要安装 Python 2.7 版本的，太高或者太低均会报错！</p>
<p>安装完成后，将 Python 所在目录添加到 PATH 环境变量中，并通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set PTATH=C:</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p>
<p>使环境变量生效，确认 Python 是否已经正确配置，执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where python</span><br></pre></td></tr></table></figure></p>
<p>如果可以有效输出 python.exe 所在目录，则配置正确。</p>
<h2 id="4、安装-depot-tools"><a href="#4、安装-depot-tools" class="headerlink" title="4、安装 depot_tools"></a>4、安装 depot_tools</h2><p>安装 WebRTC 代码下载工具 depot_tools（Google），参考页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://dev.chromium.org/developers/how-tos/install-depot-tools</span><br></pre></td></tr></table></figure></p>
<p>，Windows 下设置环境变量，需将 depot_toolss 所在目录添加到环境变量 ‘PATH’ 的最前面（目录中不要有空格），记得在标准的 cmd 中执行下 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gclient</span><br></pre></td></tr></table></figure>
<p>命令，首次启动，它会自动下载安装所依赖的一些工具，<strong>但切记不要在非标准的 cmd 中执行此命令，如 cmder</strong>；</p>
<h2 id="5、下载安装-Windows-SDK-10"><a href="#5、下载安装-Windows-SDK-10" class="headerlink" title="5、下载安装 Windows SDK 10"></a>5、下载安装 Windows SDK 10</h2><p>官方下载地址 <a href="https://developer.microsoft.com/zh-cn/windows/downloads/windows-10-sdk" target="_blank" rel="noopener">Windows10 sdk</a></p>
<p>并配置环境变量 WINDOWSSDKDIR 指向 SDK 安装目录，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINDOWSSDKDIR=D:\Windows Kits\10</span><br></pre></td></tr></table></figure>
<h2 id="6、修改系统语言"><a href="#6、修改系统语言" class="headerlink" title="6、修改系统语言"></a>6、修改系统语言</h2><p>首先更改 Windows 系统区域语言为  英语，具体方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Control Panel → System and Security → System → Advanced system settings</span><br><span class="line">中文：</span><br><span class="line">控制面板-&gt;时钟、语言和区域-&gt;区域-&gt;管理（选项卡）-&gt;更改系统区域设置； 并重启</span><br></pre></td></tr></table></figure>
<h2 id="7、-设置默认编译工具-IDE-版本"><a href="#7、-设置默认编译工具-IDE-版本" class="headerlink" title="7、 设置默认编译工具 IDE 版本"></a>7、 设置默认编译工具 IDE 版本</h2><p>系统环境变量中添加变量 DEPOT_TOOLS_WIN_TOOLCHAIN ，值设为 0；这个环境变量作用是告诉 deppt_tools 使用本地已安装的默认的 Visual Studio 版本去编译；否则 depot_tools 会使用 Google 内部默认的版本；</p>
<h2 id="8、设置环境变量，用于生成-VS-工程文件"><a href="#8、设置环境变量，用于生成-VS-工程文件" class="headerlink" title="8、设置环境变量，用于生成 VS 工程文件"></a>8、设置环境变量，用于生成 VS 工程文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set DEPOT_TOOLS_WIN_TOOLCHAIN=0</span><br><span class="line">set GYP_GENERATORS=ninja,msvs-ninja</span><br><span class="line">set GYP_MSVS_VERSION=2015</span><br></pre></td></tr></table></figure>
<h2 id="9、安装-DirectX-SDk"><a href="#9、安装-DirectX-SDk" class="headerlink" title="9、安装 DirectX SDk"></a>9、安装 DirectX SDk</h2><p>安装DirectX SDK June 2010，安装完成后可能会报错，错误代码“s1023”,这是因为与系统已有的visual c++ redistributable packages版本冲突，不用管它，直接退出安装程序即可。这里我们需要的只是安装目录下的头文件和库。</p>
<p>#二、 下载 WebRTC 源码</p>
<p>注：CMD 命令行窗口使用管理员权限打开；</p>
<h2 id="1、下载源码"><a href="#1、下载源码" class="headerlink" title="1、下载源码"></a>1、下载源码</h2><p>选定好 WebRTC 源码存放目录后，如 E:/OpenSource 目下，通过 CMD 进入此目录，依次执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir webrtc-checkout</span><br><span class="line">cd webrtc-checkout</span><br><span class="line">fetch --nohooks webrtc</span><br><span class="line">gclient sync</span><br></pre></td></tr></table></figure>
<p>前三条命令一次获取 WebRTC 源码，需要下载较长的时间。</p>
<p>如果在执行 gclient sync 命令时，发现以下错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Please follow the instructions at https://www.chromium.org/developers/how-tos/build-instructions-windows                                                                          </span><br><span class="line">***</span><br><span class="line">returned non-zero exit status 1 in E:\OpenSource\webrtc-checkout</span><br></pre></td></tr></table></figure>
<p>仔细查看报错信息，可以看到，命令执行失败，并建议我们先参考</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.chromium.org/developers/how-tos/build-instructions-windows</span><br></pre></td></tr></table></figure>
<p>指导页完成 Windows 下的一些编译准备工作，可能是漏掉了一些前期准备工作，主要是</p>
<p><strong>更改 Windows 系统区域语言为  英语</strong> </p>
<p>具体方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Control Panel → System and Security → System → Advanced system settings</span><br><span class="line">中文：</span><br><span class="line">控制面板-&gt;时钟、语言和区域-&gt;区域-&gt;管理（选项卡）-&gt;更改系统区域设置； 并重启</span><br></pre></td></tr></table></figure>
<p><strong>系统环境变量中添加变量 DEPOT_TOOLS_WIN_TOOLCHAIN ，值设为 0</strong> </p>
<p>这个环境变量作用是告诉 deppt_tools 使用本地已安装的默认的 Visual Studio 版本去编译；否则 depot_tools 会使用 Google 内部默认的版本；</p>
<p>至此环境已经彻底准备好，重新执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gclient sync</span><br></pre></td></tr></table></figure></p>
<p>命名执行成功！</p>
<h2 id="2、-可选项：指定如何跟踪处理新的分支"><a href="#2、-可选项：指定如何跟踪处理新的分支" class="headerlink" title="2、 可选项：指定如何跟踪处理新的分支"></a>2、 可选项：指定如何跟踪处理新的分支</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config branch.autosetupmerge always</span><br><span class="line">git config branch.autosetuprebase always</span><br></pre></td></tr></table></figure>
<p>  <strong>git config branch.autosetupmerge always</strong></p>
<p>  表示 自动从远程分支合并提交到本地分支，如果不做此设置，你需要手动 merge；</p>
<p>  <strong>git config branch.autosetuprebase always</strong></p>
<p>  设置在执行 git pull  命令时做 rebase 而不是是 merge；可选的值还有 never：不自动 rebase， local 跟踪本地分支进行 rebase， remote 跟踪远程分支进行 rebase， always 所有跟踪的分支都自动进行 rebase；  ​</p>
<h2 id="3、-可选项：创建一个新的本地分支"><a href="#3、-可选项：创建一个新的本地分支" class="headerlink" title="3、 可选项：创建一个新的本地分支"></a>3、 可选项：创建一个新的本地分支</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">git checkout master</span><br><span class="line">git new-branch your-branch-name</span><br></pre></td></tr></table></figure>
<p>  建议创建下新的本地开发分支，如： git new-branch dev  ​</p>
<ul>
<li><p>编译前更新下最新代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>如果在上一步中，没有创建新的分支，则使用</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure>
<p>命令代替，以获取最新代码。</p>
</li>
</ul>
<p><strong>注：</strong>由于WebRTC 目前还在频繁的更新中，建议定期的去下载更新下编译工具链及其依赖，通过执行<br>gclient sync 既可!</p>
<h1 id="三、编译"><a href="#三、编译" class="headerlink" title="三、编译"></a>三、编译</h1><p>WebRTC  目前使用 GN 来生成构建脚本，Ninja 进行构建，所以系统平台均是。</p>
<p>所以网上说的通过 GYP 生成 VS 解决方案工程文件的博文都已失效，用的均为旧版本的 webrtc。</p>
<h2 id="1、通过-Ninja-编译"><a href="#1、通过-Ninja-编译" class="headerlink" title="1、通过 Ninja 编译"></a>1、通过 Ninja 编译</h2><h3 id="a、-生成-Ninja-工程文件"><a href="#a、-生成-Ninja-工程文件" class="headerlink" title="a、 生成 Ninja 工程文件"></a>a、 生成 Ninja 工程文件</h3><p>Ninja 工程文件由 GN 生成，为其选择一个放置的目录中，如 out/Debug 或者 out/Release，这里官方建议选择 out/Default 这样可以放置 debug 和 release，在 src 目录下还行一下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn gen out/Default</span><br></pre></td></tr></table></figure>
<p>如果 提示 gn 命令 not found，需检查 depot_tools 环境变量设置是否生效。</p>
<p>执行以下命令生成 Ninja 工程文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn gen out/Default</span><br></pre></td></tr></table></figure>
<p>如果需要生成 release 工程文件，需在后面加上关闭 debug 的参数  <strong>–args=is_debug= false</strong></p>
<p>如果需要清理 Ninja 工程文件，但保持 GN 环境配置不变的话，可以执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn clean out/Default</span><br></pre></td></tr></table></figure>
<h3 id="b、通过-Ninja-命令编译"><a href="#b、通过-Ninja-命令编译" class="headerlink" title="b、通过 Ninja 命令编译"></a>b、通过 Ninja 命令编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja -C out/Default</span><br></pre></td></tr></table></figure>
<h2 id="2、通过-VS-IDE-编译"><a href="#2、通过-VS-IDE-编译" class="headerlink" title="2、通过 VS IDE 编译"></a>2、通过 VS IDE 编译</h2><p>除了 ninja 外，其他的构建系统不受支持(可能会失败)，比如Windows上的Visual Studio或者OSX上的Xcode。GN支持一种混合使用的方法，即由 Visual studio/xcode 用于编辑和驱动编译。</p>
<p>官方原文如下：</p>
<p>Other build systems are <strong>not supported</strong> (and may fail), such as Visual Studio on Windows or Xcode on OSX. GN supports a hybrid approach of using <a href="https://ninja-build.org/" target="_blank" rel="noopener">Ninja</a> for building, but Visual Studio/Xcode for editing and driving compilation.</p>
<h3 id="a、生成-VS-解决方案工程文件"><a href="#a、生成-VS-解决方案工程文件" class="headerlink" title="a、生成 VS 解决方案工程文件"></a>a、生成 VS 解决方案工程文件</h3><p>src 目录下执行以下命令（默认生成 Debug ）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn gen --ide=vs out/Debug</span><br></pre></td></tr></table></figure></p>
<p>会在 out/VS 目录下生成 all.sln 解决方案文件；如果需要生成 release 工程文件，需在后面加上关闭 debug 的参数  <strong>–args=’is_debug= false’</strong><br>即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn gen --ide=vs out/Release --args=is_debug= false</span><br></pre></td></tr></table></figure></p>
<h3 id="b、打开-all-sln-文件编译"><a href="#b、打开-all-sln-文件编译" class="headerlink" title="b、打开 all.sln 文件编译"></a>b、打开 all.sln 文件编译</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzlc.github.io/2018/01/28/Windows-下编译-WebRTC/" data-id="cjr7fkkma000j4ouv5elrrwxc" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    
  <div class="widget-wrap">
     
        <h3 class="follow-title ">Follow me</h3>
     
    <div class="widget follow">
      
              <a class="github" aria-hidden="true" href="https://github.com/zzlc" target="_blank" title="Github"></a>
      
      
      
      
            <a class="email" aria-hidden="true"  href="mailto:chengaobao@gmail.com" target="_blank" title="邮箱"></a>
      
    </div>
  </div>


  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title categories">分类</h3>
    <div class="widget" id="categories">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPC/">OPC</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RTC/">RTC</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/经验总结/">经验总结</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title tagcloud">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/WebRTC-windows/" style="font-size: 14px;">WebRTC windows</a> <a href="/tags/WebRTC-Thread/" style="font-size: 14px;">WebRTC::Thread</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/12/WebRtc Windows develop patch 记录/">WebRtc Windows develop patch 记录</a>
          </li>
        
          <li>
            <a href="/2018/03/30/WebRtc-源码分析之-rtc-Thread/">WebRTC 源码阅读之 rtc::Thread</a>
          </li>
        
          <li>
            <a href="/2018/03/22/Linux-常用命令备忘录/">Linux 常用命令备忘录</a>
          </li>
        
          <li>
            <a href="/2018/03/19/解决-WebRTC-花屏问题记录/">解决 WebRTC 花屏问题记录</a>
          </li>
        
          <li>
            <a href="/2018/03/12/BOOST-在-Windows-下通过-VS-进行编译/">BOOST 在 Windows 下通过 VS 进行编译</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title archive">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>


  
    
<div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
        <ul>
            
            <li>
                <a href="https://www.jianshu.com/u/f547ea0c9dd9">我的简书</a>
            </li>
            
        </ul>
    </div>
</div>

  
    <!--微信公众号二维码-->

  <div class="widget-wrap">
    <h3 class="follow-title ">我的微信号</h3>
    <div class="widget wechat-widget">
        <img src="/images/webchat.png" alt="扫码关注" width="250"/>
    </div>
  </div>


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2019 陈高报&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;18621626807@163.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.4/latest.js"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>