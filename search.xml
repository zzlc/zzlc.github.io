<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webrtc on linux alsa audio device blocking</title>
      <link href="/posts/a2661658.html"/>
      <url>/posts/a2661658.html</url>
      
        <content type="html"><![CDATA[<p>基于 webrtc 开发嵌入式 linux 实时音视频，其中音频 alsa 模块存在一个不小的 Bug，在较多的声卡上存在播放失败并阻塞的严重问题，问题如下：<br>存在大概率的声卡打开失败，即 <code>snd_pcm_prepare</code> 失败的概率，在 源码中 webrtc 会尝试通过 <code>ErrorRecovery</code> 恢复声卡至正确的状态，但是执行到 <code>snd_pcm_recover</code> 输出 <code>underrun occurred</code> 错误信息后便阻塞了。</p><p>原因在于 <code>snd_pcm_recover</code> 源码中会调动 <code>snd_pcm_prepare</code> 方法尝试恢复声卡状态，但是 <code>snd_pcm_prepare</code> 会首先获取 <code>snd_pcm_t</code> 中的线程锁 <code>pthread_mutex_t</code>，而 webrtc 在 <code>AudioDeviceLinuxALSA::StartPlayout()</code> 方法中是先启动播放线程，然后再调用 <code>snd_pcm_prepare</code> 准备好声卡设备，导致线程有一定概率启动速度早于父线程中对 <code>snd_pcm_prepare</code> 的调用，最终播放线程中在执行 <code>snd_pcm_avail_update</code> 失败，触发 <code>ErrorRecovery</code> 方法，内部有线程锁，导致线程死锁，整个 APP Blocking；</p><p>修复方式比较简单，修改 <code>audio_device_alsa_linux.cc</code> 文件中的 <code>StartPlayout</code> 方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> AudioDeviceLinuxALSA::StartPlayout() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_playIsInitialized) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_playing) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _playing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  _playoutFramesLeft = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!_playoutBuffer)</span><br><span class="line">    _playoutBuffer = <span class="keyword">new</span> <span class="keyword">int8_t</span>[_playoutBufferSizeIn10MS];</span><br><span class="line">  <span class="keyword">if</span> (!_playoutBuffer) &#123;</span><br><span class="line">    RTC_LOG(LS_ERROR) &lt;&lt; <span class="string">"failed to alloc playout buf"</span>;</span><br><span class="line">    _playing = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> errVal = LATE(snd_pcm_prepare)(_handlePlayout);</span><br><span class="line">  <span class="keyword">if</span> (errVal &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    RTC_LOG(LS_ERROR) &lt;&lt; <span class="string">"playout snd_pcm_prepare failed ("</span></span><br><span class="line">                      &lt;&lt; LATE(snd_strerror)(errVal) &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">    <span class="comment">// just log error</span></span><br><span class="line">    <span class="comment">// if snd_pcm_open fails will return -1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将线程的启动放到 snd_pcm_prepare 之后再启动</span></span><br><span class="line">  <span class="comment">// PLAYOUT</span></span><br><span class="line">  _ptrThreadPlay.reset(<span class="keyword">new</span> rtc::PlatformThread(</span><br><span class="line">      PlayThreadFunc, <span class="keyword">this</span>, <span class="string">"webrtc_audio_module_play_thread"</span>));</span><br><span class="line">  _ptrThreadPlay-&gt;Start();</span><br><span class="line">  _ptrThreadPlay-&gt;SetPriority(rtc::kRealtimePriority);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebRTC Linux alsa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mediasoup 公网环境部署</title>
      <link href="/posts/3784820804.html"/>
      <url>/posts/3784820804.html</url>
      
        <content type="html"><![CDATA[<p>最近以来一直基于 mediasoup 开发 rtc 相关产品，一直想基于 mediasoup 搭建自己的一套基础的 rtc 环境，用于自己练习 golang、rust 的开发、学习和测试，内网下搭建 mediasoup 比较简单，参照官网的文档一步步来很容易就能搞定，不过如果要在公网下搭建一套环境，相对来说略微麻烦些，需要云主机、nginx 配置、https 配置，通过这篇文章记录上述环境搭建的关键步骤。</p><blockquote><p>以下操作均在 Ubuntu 18.04 Server 系统上操作。</p></blockquote><h1 id="准备云主机"><a href="#准备云主机" class="headerlink" title="准备云主机"></a>准备云主机</h1><p>公网环境的搭建还是需要一台拥有公网 IP 的主机的，当然如果你能薅公司的羊毛就更好了 。。本人的是阿里云主机 Ubuntu 系统 16.04 upgrade to 18.04，双11 时买的最便宜的机型，同时安装 ssh、 git、nodejs、npm，开启远程登录。</p><h1 id="域名准备"><a href="#域名准备" class="headerlink" title="域名准备"></a>域名准备</h1><p>通过浏览器打开音视频设备因为有安全方面的限制，不能通过 IP 进行访问，必须通过 <a href="https://domain" target="_blank" rel="noopener">https://domain</a> 的 url 打开，所以我们还需要准备一个域名并解析到我们自己的公网 IP 地址，域名也可以通过阿里云进行购买，因为不需要 seo，所以选一个最便宜的后缀即可，我选择了 <code>gobert.top</code>，第一年只有 9 元，后面还需要域名备案，否则域名将被重定向到指定地址，所以域名需要提前准备。</p><blockquote><p>首次域名备案相对来说比较麻烦，需要准备居住证（来沪外来人员）等证件，各种审核需要耗时两三天吧。</p></blockquote><h1 id="安装-mediasoup"><a href="#安装-mediasoup" class="headerlink" title="安装 mediasoup"></a>安装 mediasoup</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">λ ssh gobert@47.100.110.xxx</span><br><span class="line">gobert@47.100.110.xxx&apos;s password:</span><br><span class="line">Welcome to Ubuntu 18.04.1 LTS (GNU/Linux 4.15.0-38-generic x86_64)</span><br><span class="line"></span><br><span class="line">Last login: Mon Apr  1 17:28:34 2019 from 116.236.177.xxx</span><br><span class="line">$ mkdir develop</span><br><span class="line">$ cd develop</span><br><span class="line">$ git clone git@github.com:versatica/mediasoup-demo.git</span><br></pre></td></tr></table></figure><p>后续 npm 的安装需参照 <code>https://github.com/versatica/mediasoup-demo/</code> 文档进行。</p><h1 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h1><blockquote><p>这一步默认域名购买、解析、备案已完成。</p></blockquote><h2 id="在线安装-nginx"><a href="#在线安装-nginx" class="headerlink" title="在线安装 nginx"></a>在线安装 nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install nginx</span><br></pre></td></tr></table></figure><h2 id="部署-mediasoup-到-nginx"><a href="#部署-mediasoup-到-nginx" class="headerlink" title="部署 mediasoup 到 nginx"></a>部署 mediasoup 到 nginx</h2><blockquote><p>将 mediasoup 中的 server 目录拷贝到 nginx 根目录下。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir -p /var/www/mediasoup</span><br><span class="line">$ sudo cp -r medissoup-demo/server/ /var/www/mediasoup/</span><br></pre></td></tr></table></figure><p>配置 nginx 解析到以上目录，编辑 <code>/etc/nginx/sites-available/default</code> 配置文件，将 server 根路径下的 root 属性修改为 <code>/var/www/mediasoup/server/public;</code>,即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 以上省略</span><br><span class="line">#root /var/www/html;</span><br><span class="line">root /var/www/mediasoup/server/public;</span><br><span class="line"></span><br><span class="line"># Add index.php to the list if you are using PHP</span><br><span class="line">index index.html index.htm index.nginx-debian.html;</span><br><span class="line"># 以下省略</span><br></pre></td></tr></table></figure><h2 id="配置-https-服务"><a href="#配置-https-服务" class="headerlink" title="配置 https 服务"></a>配置 https 服务</h2><p>通过浏览器打开设备需要 https 安全 url，nginx 必须开启 https 服务，通过 letsencrypt 进行 https 的自动化配置，省去了自己很多的麻烦，不用再去申请证书、审核、验证部署等繁琐的操作了，通过 <code>https://certbot.eff.org/lets-encrypt/ubuntubionic-nginx</code> 下的命令按步执行即可。</p><p><img src="/images/letsencrypt.png" alt="rtc::Thread UML 类图"></p><blockquote><p>letsencrpt 安装的 ssl 证书只有三个月的有效期，所以为了防止证书过期，建议添加系统定时任务，定期执行脚本命令更新证书：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ su -</span><br><span class="line">$ certbot renew --dry-run</span><br></pre></td></tr></table></figure><p>正常情况下，你的 nginx 已经开启了 https 服务, ssl 证书及秘钥存放位置记录在 <code>/etc/nginx/sites-available/default</code> 配置文件中，打开 <code>/etc/nginx/sites-available/default</code> 文件，发现 letsencrpty 自动在脚本末尾增加了一项 server 配置，将 <code>root</code> 路径配置为以上 <code>/var/www/mediasoup/server/public;</code> 目录，同时记录下其 ssl_certificate 目录，后面 nginx 配置中需要指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listen [::]:443 ssl ipv6only=on; # managed by Certbot</span><br><span class="line">listen 443 ssl; # managed by Certbot</span><br><span class="line">ssl_certificate /etc/letsencrypt/live/www.gobert.top/fullchain.pem; # managed by Certbot</span><br><span class="line">ssl_certificate_key /etc/letsencrypt/live/www.gobert.top/privkey.pem; # managed by Certbot</span><br><span class="line">include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span><br></pre></td></tr></table></figure><h2 id="配置-mediasoup-server"><a href="#配置-mediasoup-server" class="headerlink" title="配置 mediasoup server"></a>配置 mediasoup server</h2><ul><li>配置自定义脚本：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ copy config.example.js config.js</span><br></pre></td></tr></table></figure><p>打开 config.js 文件，在 tls 路径中，将上面记录的 letsencrypt 证书路径拷贝到相应的 item 中，同时修改 <code>rtcAnnouncedIPv4</code> 为云主机公网 IP 地址，完整的 config.js 的文件为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">module.exports =</span><br><span class="line">&#123;</span><br><span class="line">        // Listening hostname for `gulp live|open`.</span><br><span class="line">        domain : &apos;localhost&apos;,</span><br><span class="line">        tls    :</span><br><span class="line">        &#123;</span><br><span class="line">                cert : `/etc/letsencrypt/live/www.gobert.top/fullchain.pem`, // letsencrypt 证书</span><br><span class="line">                key  : `/etc/letsencrypt/live/www.gobert.top/privkey.pem`    // letsencrypt 秘钥</span><br><span class="line">        &#125;,</span><br><span class="line">        mediasoup :</span><br><span class="line">        &#123;</span><br><span class="line">                // mediasoup Server settings.</span><br><span class="line">                logLevel : &apos;warn&apos;,</span><br><span class="line">                logTags  :</span><br><span class="line">                [</span><br><span class="line">                        &apos;info&apos;,</span><br><span class="line">                        &apos;ice&apos;,</span><br><span class="line">                        &apos;dtls&apos;,</span><br><span class="line">                        &apos;rtp&apos;,</span><br><span class="line">                        &apos;srtp&apos;,</span><br><span class="line">                        &apos;rtcp&apos;,</span><br><span class="line">                        // &apos;rbe&apos;,</span><br><span class="line">                        // &apos;rtx&apos;</span><br><span class="line">                ],</span><br><span class="line">                numWorkers       : null, // Use number of CPUs.</span><br><span class="line">                rtcIPv4          : true,</span><br><span class="line">                rtcIPv6          : true,</span><br><span class="line">                rtcAnnouncedIPv4 : &apos;47.100.110.192&apos;, // 云主机公网地址</span><br><span class="line">                rtcAnnouncedIPv6 : null,  // 根据需要，自主填写</span><br><span class="line">                rtcMinPort       : 40000, // udp 最小端口，需要云主机安全组中配置</span><br><span class="line">                rtcMaxPort       : 49999, // dup 最大端口，需要云主机安全组中配置</span><br><span class="line">                // mediasoup Room codecs.</span><br><span class="line">                mediaCodecs      :</span><br><span class="line">                [</span><br><span class="line">                        &#123;</span><br><span class="line">                                kind       : &apos;audio&apos;,</span><br><span class="line">                                name       : &apos;opus&apos;,</span><br><span class="line">                                mimeType   : &apos;audio/opus&apos;,</span><br><span class="line">                                clockRate  : 48000,</span><br><span class="line">                                channels   : 2,</span><br><span class="line">                                parameters :</span><br><span class="line">                                &#123;</span><br><span class="line">                                        useinbandfec : 1</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                kind       : &apos;video&apos;,</span><br><span class="line">                                name       : &apos;VP8&apos;,</span><br><span class="line">                                mimeType   : &apos;video/VP8&apos;,</span><br><span class="line">                                clockRate  : 90000,</span><br><span class="line">                                parameters :</span><br><span class="line">                                &#123;</span><br><span class="line">                                        &apos;x-google-start-bitrate&apos;: 1500</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                kind       : &apos;video&apos;,</span><br><span class="line">                                name       : &apos;h264&apos;,</span><br><span class="line">                                mimeType   : &apos;video/h264&apos;,</span><br><span class="line">                                clockRate  : 90000,</span><br><span class="line">                                parameters :</span><br><span class="line">                                &#123;</span><br><span class="line">                                        &apos;packetization-mode&apos;      : 1,</span><br><span class="line">                                        &apos;profile-level-id&apos;        : &apos;42e01f&apos;,</span><br><span class="line">                                        &apos;level-asymmetry-allowed&apos; : 1</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                ],</span><br><span class="line">                // mediasoup per Peer max sending bitrate (in bps).</span><br><span class="line">                maxBitrate : 500000</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>修改 Server 监听端口</li></ul><blockquote><p>此处修改 server 的监听端口其实没什么意义，可以忽略。</p></blockquote><p>编辑 <code>server.js</code> 配置文件，将默认端口 <code>httpsServer.listen(3443, &#39;0.0.0.0&#39;, () =&gt;</code> 替换为 <code>httpsServer.listen(5678, &#39;0.0.0.0&#39;, () =&gt;</code>。</p><ul><li>配置 Client 访问 Server WSS 地址</li></ul><p>打开 <code>public/mediasoup-demo-app.js</code> 将 <code>getProtooUrl</code> 方法中的 URL 地址端口改为自定义的 <code>5678</code> 端口：</p><blockquote><p>如果上一步中没有修改 server 的监听端口的话，这一步也可忽略。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getProtooUrl(peerName, roomId, forceH264) &#123;</span><br><span class="line">  var hostname = window.location.hostname;</span><br><span class="line">  var url = &quot;wss://&quot;.concat(hostname, &quot;:5678/?peerName=&quot;).concat(peerName, &quot;&amp;roomId=&quot;).concat(roomId);</span><br><span class="line">  if (forceH264) url = &quot;&quot;.concat(url, &quot;&amp;forceH264=true&quot;);</span><br><span class="line">  return url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动-mediasoup-server"><a href="#启动-mediasoup-server" class="headerlink" title="启动 mediasoup server"></a>启动 mediasoup server</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /var/www/mediasoup/server</span><br><span class="line">$ sudo DEBUG=&quot;*mediasoup* *ERROR* *WARN*&quot; INTERACTIVE=&quot;true&quot; node server.js</span><br></pre></td></tr></table></figure><h2 id="重启-nginx"><a href="#重启-nginx" class="headerlink" title="重启 nginx"></a>重启 nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nginx -s reload</span><br></pre></td></tr></table></figure><h1 id="在线体验"><a href="#在线体验" class="headerlink" title="在线体验"></a>在线体验</h1><blockquote><p>此主机带宽比较低，初次打开比较慢，需耐心等待加载完成，后面缓冲后速度会变化，音视频延迟不受影响。</p></blockquote><p>在两个终端浏览器（支持 Chrome、Firefox、Safari）中均打开 <code>https://www.gobert.top/?roomId=123456</code> 即可体验，RoomId 可自定义，效果图：</p><p><img src="/images/mediasoup-brower.png" alt="连麦效果图"></p>]]></content>
      
      
      <categories>
          
          <category> RTC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-目标</title>
      <link href="/posts/239554791.html"/>
      <url>/posts/239554791.html</url>
      
        <content type="html"><![CDATA[<p>给自己制定一个 2019 年的目标，2018 年给自己制定的任务完成的很不好，在此立个 Flag，2019 年务实不务虚，拓宽自己未来的道路。</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><ul><li>阅读 5 本专业以外的书籍</li><li>将京东上已购的情商方面的书籍读完</li><li>阅读一本可提高自己视野和创新性的书籍</li></ul><h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><ul><li>提高自己英语听、说、读、写能力，打破这种限制自己继续前进的障碍</li><li>在流媒体圈子中打造个人品牌！！！</li></ul><h2 id="财务目标"><a href="#财务目标" class="headerlink" title="财务目标"></a>财务目标</h2><ul><li>突破只有薪资一种收入来源的困境，创造一种工资以外的稳定收入来源，为实现财务自由而努力。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基于 webrtc 进行流媒体开发</title>
      <link href="/posts/3440048822.html"/>
      <url>/posts/3440048822.html</url>
      
        <content type="html"><![CDATA[<p>在 Linux 平台下开发实时通话 SDK 其实是主要应用于未来的 IOT 行业，先基于 Ubuntu 作为开发平台，完成后再基于每个客户提供的其交叉编译工具链进行交叉编译以供用户使用。</p><h2 id="基于-Ubuntu-下载-webrtc"><a href="#基于-Ubuntu-下载-webrtc" class="headerlink" title="基于 Ubuntu 下载 webrtc"></a>基于 Ubuntu 下载 webrtc</h2><h3 id="自行下载编译"><a href="#自行下载编译" class="headerlink" title="自行下载编译"></a>自行下载编译</h3><p>如果是自己下载编译的话，可以参考官方教程，或者参考本人之前的一篇博客： <a href="https://www.jianshu.com/p/09f065f3feb0" target="_blank" rel="noopener">https://www.jianshu.com/p/09f065f3feb0</a> ，其实 Ubuntu 下编译 webrtc 是比较简单的，只要可以翻墙，其它都只是时间问题了。</p><h3 id="无法翻墙下载"><a href="#无法翻墙下载" class="headerlink" title="无法翻墙下载"></a>无法翻墙下载</h3><p>那么可以通过下载本人配置的一个 Docker 镜像进行进行编译： <a href="https://hub.docker.com/r/cgb0210/ubuntu_build" target="_blank" rel="noopener">https://hub.docker.com/r/cgb0210/ubuntu_build</a> ，由于 Docker 不适合作为开发环境，下载后，建议用户将 develop 目录下的文件拷贝到自己的开发环境中，并参考 <a href="https://www.jianshu.com/p/09f065f3feb0" target="_blank" rel="noopener">https://www.jianshu.com/p/09f065f3feb0</a> 配置相关环境变量，实现本地编译,过程主要包含 3 步：</p><h3 id="配置-depot-tools-环境变量"><a href="#配置-depot-tools-环境变量" class="headerlink" title="配置 depot_tools 环境变量"></a>配置 depot_tools 环境变量</h3><p>将 <code>export PATH=$PATH:/home/gobert/develop/depot_tools</code> 添加到 <code>/etc/profile</code> 文件尾部；</p><h3 id="安装-GoLang-并配置环境"><a href="#安装-GoLang-并配置环境" class="headerlink" title="安装 GoLang 并配置环境"></a>安装 GoLang 并配置环境</h3><h3 id="安装-Linux-依赖包"><a href="#安装-Linux-依赖包" class="headerlink" title="安装 Linux 依赖包"></a>安装 Linux 依赖包</h3><p>执行 webrtc 目录下的 <code>/build/install-build-deps.sh</code> 脚本命令，如： <code>sudo sh build/install-build-deps.sh</code>；</p><h2 id="编译-webrtc"><a href="#编译-webrtc" class="headerlink" title="编译 webrtc"></a>编译 webrtc</h2><p>默认情况下，Linux 下基于 ninja 编译的话，其编译器使用的是 clang，且其依赖的 stdc 标准库为其 ./buildtools/third_party/libc++ 内置的，所以如果外部想要基于 clang 编译的 libwebrtc.a 进行开发的话，上层依然需要使用 clang 做为编译器，且链接 webrtc 内部的 libc++ 标准库，否则将会产生各种 <code>error: undefined reference to symbol ...</code>，无法解决，虽然 clang 比 g++ 要优秀很多，但本人目前还是习惯使用 g++ 进行开发，所以需要指定 g++ 编译器，同时需要注意以下事项：</p><h3 id="RTTI-（Run-Time-Type-Identification-运行时类型识别）"><a href="#RTTI-（Run-Time-Type-Identification-运行时类型识别）" class="headerlink" title="RTTI （Run-Time Type Identification 运行时类型识别）"></a>RTTI （Run-Time Type Identification 运行时类型识别）</h3><p>webrtc 内部各模块配置了不同的 rtti 属性，开、关各不相同，默认情况下，加载 libwebrtc.a 会产生 <code>undefined reference to</code>typeinfo for [classname]’<code>错误，为此我们可以在链接 libwebrtc.a 的根编译脚本文件中配置统一去除 rtti 属性，以解决此类问题，打开根目录下的 BUILD.gn 文件，在</code>rtc_static_library(“webrtc”)<code>尾部添加</code>cflags_cc = [“ -fno-rtti” ]` 即可，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (!build_with_chromium) &#123;</span><br><span class="line"># Target to build all the WebRTC production code.</span><br><span class="line">rtc_static_library(&quot;webrtc&quot;) &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    cflags_cc = [&quot; -fno-rtti&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样便可以解决所有 undefined reference to <code>typeinfo for [classname]&#39;</code> 类的错误。</p><h3 id="找不到-builtin-audio-decoder-factory-模块的所有符号"><a href="#找不到-builtin-audio-decoder-factory-模块的所有符号" class="headerlink" title="找不到 builtin_audio_decoder_factory 模块的所有符号"></a>找不到 builtin_audio_decoder_factory 模块的所有符号</h3><p>这应该是 webrtc branch：68 版本的 bug，在各平台均会出现此类问题，原因在于其在编译脚本中漏写了 <code>builtin_audio_decoder_factory</code> 模块，加上即可，打开 <code>audio/BUILD.gn</code> 文件，在 <code>&quot;../api/audio_codecs:builtin_audio_encoder_factory&quot;,</code> 下面添加一行 <code>&quot;../api/audio_codecs:builtin_audio_decoder_factory&quot;,</code> 即可。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ggn gen -C out/linux/Release  --args=&quot;is_debug=false target_cpu=\&quot;x64\&quot; rtc_include_tests=false rtc_use_h264=true rtc_initialize_ffmpeg=true ffmpeg_branding=\&quot;Chrome\&quot; is_component_build=false is_clang=false treat_warnings_as_errors=false use_custom_libcxx=false strip_debug_info=true use_rtti=false&quot;</span><br></pre></td></tr></table></figure><p>其中 <code>rtc_include_tests=false</code> 为禁止编译单元测试程序，可大大节省编译时间；<br><code>rtc_use_h264=true rtc_initialize_ffmpeg=true ffmpeg_branding=\&quot;Chrome\&quot;</code> 为激活内部 H.264 编解码器。</p><h2 id="Demo-程序"><a href="#Demo-程序" class="headerlink" title="Demo 程序"></a>Demo 程序</h2><h3 id="编译测试程序加载并调用-webrtc-接口。"><a href="#编译测试程序加载并调用-webrtc-接口。" class="headerlink" title="编译测试程序加载并调用 webrtc 接口。"></a>编译测试程序加载并调用 webrtc 接口。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"api/jsep.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> webrtc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SdpParseError error;</span><br><span class="line">    <span class="keyword">auto</span> ptr = CreateSessionDescription(<span class="string">"offer"</span>, <span class="string">"sdp"</span>, &amp;error);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CreateSessionDescription return null, error str:%s\n"</span>, error.description.c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CreateSessionDescription success!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-CMakeLists-txt-脚本文件"><a href="#编写-CMakeLists-txt-脚本文件" class="headerlink" title="编写 CMakeLists.txt 脚本文件"></a>编写 CMakeLists.txt 脚本文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.5)</span><br><span class="line">project(demo)</span><br><span class="line"></span><br><span class="line">set(CMAKE_POSITION_INDEPENDENT_CODE     TRUE)</span><br><span class="line"></span><br><span class="line">set(CMAKE_C_FLAGS               &quot;$&#123;CMAKE_C_FLAGS&#125;&quot;)</span><br><span class="line">SET(CMAKE_CXX_FLAGS             &quot;$&#123;CMAKE_CXX_FLAGS&#125; -fno-exceptions -fPIC&quot;)</span><br><span class="line">set(CMAKE_SHARED_LINKER_FLAGS   &quot;$&#123;CMAKE_SHARED_LINKER_FLAGS&#125;&quot;)</span><br><span class="line">set(CMAKE_EXE_LINKER_FLAGS      &quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125;&quot;)</span><br><span class="line"></span><br><span class="line">set(ARCH_PATH linux)</span><br><span class="line">set(WEBRTC_PATH &quot;/home/gobert/develop/webrtc/src&quot;)</span><br><span class="line">set(WEBRTC_LIBRARY_PATH &quot;/home/gobert/develop/webrtc/src/out/Linux/Release/obj&quot;)</span><br><span class="line"></span><br><span class="line">add_definitions(</span><br><span class="line">    &quot;-DWEBRTC_POSIX&quot;</span><br><span class="line">    &quot;-DWEBRTC_LINUX&quot;</span><br><span class="line">    &quot;-DUSE_GLIB=1&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">if (Linux)</span><br><span class="line">set(ARCH_PATH linux)</span><br><span class="line">elseif (Arm)</span><br><span class="line">set(ARCH_PATH arm)</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line">include_directories(</span><br><span class="line">    $&#123;WEBRTC_PATH&#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">set(SOURCE_FILES</span><br><span class="line">    main.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">link_directories(</span><br><span class="line">    $&#123;link_directories&#125;</span><br><span class="line">    $&#123;WEBRTC_PATH&#125;/out/Linux/Release/obj</span><br><span class="line">    /usr/lib/x86_64-linux-gnu/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">link_libraries(</span><br><span class="line">    &quot;$&#123;WEBRTC_LIBRARY_PATH&#125;/libwebrtc.a&quot;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">add_executable(demo $&#123;SOURCE_FILES&#125;)</span><br><span class="line"></span><br><span class="line">TARGET_LINK_LIBRARIES(demo pthread stdc++)</span><br><span class="line"></span><br><span class="line">set_target_properties(demo PROPERTIES OUTPUT_NAME &quot;demo&quot;)</span><br></pre></td></tr></table></figure><h3 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake &amp;&amp; make</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webrtc Linux Ubuntu g++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android AEC 无效的解决方案</title>
      <link href="/posts/1837193558.html"/>
      <url>/posts/1837193558.html</url>
      
        <content type="html"><![CDATA[<p>Android 端回声消除模块在某些机型上面需要使用 16kHz 的采样率输入，否则将会产生回声问题，为此设计此特殊机型下发服务，在 Android 端启动时查询其是否在此特殊名单中，是则强制为 16kHz 采样率，否则使用默认的 48/44.1 kHz 采样率。</p><p>因为只有部分机型才会出现此类问题，并且会不断产生新的机型出现，如果在代码中写 HardCode，那么产品的发布将会很被动，因为随时可能会有新的问题机型产生，为此开发一套特殊机型下发的服务，在 APP 启动时向此服务发起请求，校验此机型是否需要配置为 16KHz，然后再启动 RTC 进行音视频通话。此服务通过 Go 进行开发。</p><p>GitHub 地址为 ：<a href="https://github.com/zzlc/rtc-aecm-android" target="_blank" rel="noopener">https://github.com/zzlc/rtc-aecm-android</a></p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>启动命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go -addr=&quot;127.0.0.1:6688&quot; -prefix=&quot;/v1/aecm/&quot; -user=&quot;root&quot; -password=&quot;123456&quot;</span><br></pre></td></tr></table></figure><blockquote><p>实际部署后根据实际目标名称进行启动，但启动参数不变，可通过 -h 查看帮助。</p></blockquote><h2 id="Android-端查询接口"><a href="#Android-端查询接口" class="headerlink" title="Android 端查询接口"></a>Android 端查询接口</h2><p>API 查询接口提供两种，一是查询指定 <code>Model</code> 是否存在于此白名单列表中，二是查询所有的白名单列表；</p><h3 id="1、查询指定-Model"><a href="#1、查询指定-Model" class="headerlink" title="1、查询指定 Model"></a>1、查询指定 <code>Model</code></h3><blockquote><p>这里及以后均假设 SEV_ADDR 即为 服务器地址。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Request Url:</span><br><span class="line">SEV_ADDR/v1/aecm</span><br><span class="line">Method: OPTIONS</span><br><span class="line"></span><br><span class="line">Request Headers:</span><br><span class="line">model=xxx</span><br><span class="line"></span><br><span class="line">Result:</span><br><span class="line">200 ok</span><br></pre></td></tr></table></figure><blockquote><p>通过返回 http status 判断 xxx 是否在白名单中，200 为是，否则为 否。</p></blockquote><h3 id="2、查询所有白名单"><a href="#2、查询所有白名单" class="headerlink" title="2、查询所有白名单"></a>2、查询所有白名单</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Request Url:</span><br><span class="line">SEV_ADDR/v1/aecm</span><br><span class="line">Method: QUERY</span><br><span class="line"></span><br><span class="line">Result:</span><br><span class="line">200 ok</span><br><span class="line">Content type: text/json</span><br><span class="line">body: json string</span><br></pre></td></tr></table></figure><blockquote><p>如果返回 200 ok，则说明查询成功，可通过 content body 的 json string 进行解析，格式如下：</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"7"</span>: &#123;</span><br><span class="line">        <span class="attr">"author"</span>: <span class="string">"gobert"</span>,</span><br><span class="line">        <span class="attr">"brand"</span>: <span class="string">"postman_brand"</span>,</span><br><span class="line">        <span class="attr">"insertTime"</span>: <span class="string">"2019-01-10 15:19:37"</span>,</span><br><span class="line">        <span class="attr">"model"</span>: <span class="string">"redmi_note4"</span>,</span><br><span class="line">        <span class="attr">"osVersion"</span>: <span class="string">"Android 6.2"</span>,</span><br><span class="line">        <span class="attr">"packageName"</span>: <span class="string">"com.org.xxx"</span>,</span><br><span class="line">        <span class="attr">"sdkVersion"</span>: <span class="string">"0.0.0"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"8"</span>: &#123;</span><br><span class="line">        <span class="attr">"author"</span>: <span class="string">"gobert"</span>,</span><br><span class="line">        <span class="attr">"brand"</span>: <span class="string">"postman_brand"</span>,</span><br><span class="line">        <span class="attr">"insertTime"</span>: <span class="string">"2019-01-10 15:19:39"</span>,</span><br><span class="line">        <span class="attr">"model"</span>: <span class="string">"redmi_note4"</span>,</span><br><span class="line">        <span class="attr">"osVersion"</span>: <span class="string">"Android 6.2"</span>,</span><br><span class="line">        <span class="attr">"packageName"</span>: <span class="string">"com.org.xxx"</span>,</span><br><span class="line">        <span class="attr">"sdkVersion"</span>: <span class="string">"0.0.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加新机型"><a href="#添加新机型" class="headerlink" title="添加新机型"></a>添加新机型</h2><p>通过以下 API 即可添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Request Url:</span><br><span class="line">SEV_ADDR/v1/aecm</span><br><span class="line">Method: ADD</span><br><span class="line"></span><br><span class="line">Request Headers:</span><br><span class="line">osVersion=Android 6.2</span><br><span class="line">brand=postman_brand</span><br><span class="line">model=xxx</span><br><span class="line">sdkVersion=1.0.0</span><br><span class="line">packageName=com.org.xxx</span><br><span class="line">author=gobert</span><br><span class="line"></span><br><span class="line">Result:</span><br><span class="line">200 ok</span><br></pre></td></tr></table></figure><h2 id="删除已有机型"><a href="#删除已有机型" class="headerlink" title="删除已有机型"></a>删除已有机型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Request Url:</span><br><span class="line">SEV_ADDR/v1/aecm</span><br><span class="line">Method:DELETE</span><br><span class="line"></span><br><span class="line">Request Headers:</span><br><span class="line">model=xxx</span><br><span class="line"></span><br><span class="line">Result:</span><br><span class="line">200 ok</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android AEC 16KHz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebRtc Windows develop patch 记录</title>
      <link href="/posts/4152150583.html"/>
      <url>/posts/4152150583.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="1、WebRtc-源码升级-m63-gt-m68"><a href="#1、WebRtc-源码升级-m63-gt-m68" class="headerlink" title="1、WebRtc 源码升级 m63-&gt;m68"></a>1、WebRtc 源码升级 m63-&gt;m68</h2><p>升级过程中主要遇到两种编译问题：一是 webrtc 本身在同步、编译过程中有问题，另外就是在使用 <code>webrtc.lib</code> 时有报错；</p><ul><li>gclient sync  一直报：下载失败，或其他失败</li></ul><blockquote><p>这是因为 python 的缓冲中还留有部分旧版本的下载地址信息，导致下载失败，或者下载后版本不对应，删除当前用户目录下的 <code>.vpython_cipd_cache</code> 和 <code>.vpython-root</code>，然后再执行 <code>gclient sync</code> 即可;</p></blockquote><ul><li>SDK 编译链接时报无 <code>builtin_audio_decoder_factory</code> 相关符号</li></ul><blockquote><p>目前出现此问题的原因未知，不过 builtin_audio_decoder_factory 符号已编译，但 audio.lib（SDK 依赖 webrtc.lib, webrtc.lib 依赖 audio.lib）确没有把 builtin_audio_decoder_factory 符号包含进去，通过修改 <code>audio/BUILD.gn</code> 脚本，在其 line：58 添加一行依赖即可：<code>../api/audio_codecs:builtin_audio_decoder_factory</code></p></blockquote><h1 id="WebRtc-内部-Bug"><a href="#WebRtc-内部-Bug" class="headerlink" title="WebRtc 内部 Bug"></a>WebRtc 内部 Bug</h1><h2 id="Adm-创建失败，导致-crash"><a href="#Adm-创建失败，导致-crash" class="headerlink" title="Adm 创建失败，导致 crash"></a>Adm 创建失败，导致 crash</h2><blockquote><p>由于 webrtc 内部会对所有设备进行一下测试，有的设备可能测试是失败（但还是可以正常采集），测试失败的话，webrtc  默认会返回 false，导致创建的 adm 为 null，而其内部却没有对这种情况做兼容，导致 crash，修复方法：在 <code>modules/audio_device/win/audio_device_core_win.cc</code> 的 line：352 添加一行：<code>ok = 0;</code> ,即忽略测试失败的情况；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> RTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebRTC windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebRTC 源码阅读之 rtc::Thread</title>
      <link href="/posts/4226121902.html"/>
      <url>/posts/4226121902.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>rtc::Thread</code> 为 WebRTC内部实现的线程类，在 WebRTC中有广泛的应用，WebRTC内部 network thread、 worker thread、signal thread 等均要求为此线程类实例；</p><p>为了线程安全，在某些功能模块的使用上，有要求其必需在指定的线程中才能调用的基本要求，比如音频模块：ADM 的创建必须要在 WebRTC 的 worker thread 中进行。</p></blockquote><h2 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h2><p><code>rtc::Thread</code> 继承自消息队列<code>rtc::MessageQueue</code> ，内部提供了丰富的创建、管理接口，其借助于 <code>线程局部存储/线程局部静态变量</code> 实现线程的安全调用，以及是否是当前线程的有效判断。<br><img src="/images/线程.png" alt="rtc::Thread UML 类图"></p><h2 id="RTC-DISALLOW-COPY-AND-ASSIGN"><a href="#RTC-DISALLOW-COPY-AND-ASSIGN" class="headerlink" title="RTC_DISALLOW_COPY_AND_ASSIGN"></a>RTC_DISALLOW_COPY_AND_ASSIGN</h2><p><code>RTC_DISALLOW_COPY_AND_ASSIGN</code> 和 <code>RTC_DISALLOW_ASSIGN</code> 配合使用，通过禁用类的拷贝构造函数 和 <code>=</code> 操作符，提高代码的安全性。</p><h2 id="rtc-Thread-成员"><a href="#rtc-Thread-成员" class="headerlink" title="rtc::Thread 成员"></a>rtc::Thread 成员</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自此类的子类，必须在其析构中主动调用 Stop 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RTC_LOCKABLE</span> <span class="title">Thread</span> :</span> <span class="keyword">public</span> MessageQueue &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 已弃用的默认构造函数，不要使用，应该使用下面的静态方法进行创建类实例</span></span><br><span class="line">  <span class="comment">// 建议在开发过程中使用 CreateWithSocketServer 创建</span></span><br><span class="line">  Thread();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Thread</span><span class="params">(SocketServer* ss)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Thread</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SocketServer&gt; ss)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有的子类均必须保证在其析构函数中或者之前明确调用 Stop() 方法</span></span><br><span class="line">  <span class="comment">// 这样做是为了避免 Thread::PreRun 调用 Run() 方法时，析构函数对虚函数表的修改</span></span><br><span class="line">  ~Thread() override;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rtc::Thread 提供的创建类实例的静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Thread&gt; CreateWithSocketServer();</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Thread&gt; Create();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回当前线程的实例指针</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Thread* <span class="title">Current</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 单实例类，在 Thread 内部作为一个友元类，辅助 Thread 用于避免在指定的作用域中同步调用 Invoke 方法</span></span><br><span class="line">  <span class="comment">// 如果发生了同步方法的调用，则会触发一个断言</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ScopedDisallowBlockingCalls</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    ScopedDisallowBlockingCalls();</span><br><span class="line">    ~ScopedDisallowBlockingCalls();</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    Thread* <span class="keyword">const</span> thread_;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> previous_state_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断调用者所在线程是否处于本线程实例中</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsCurrent</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将线程睡眠指定的毫秒数，默认返回 true，除非被 POSIX 发送的信号终止，它才会返回 false</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">SleepMs</span><span class="params">(<span class="keyword">int</span> millis)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置线程名字，它必须在 调用 Start() 之前调用，这个方法是为了方便调试时查看</span></span><br><span class="line">  <span class="comment">// 如果 @param obj 为空，它将追加到 @param name 后面</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SetName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="keyword">void</span>* obj)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始执行此线程，如果 runnable 不为空，则运行其内部的 thread，否则启动本线程</span></span><br><span class="line">  <span class="comment">// 一般传入 nullptr，即表示启动线程实例本身</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Start</span><span class="params">(Runnable* runnable = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知线程结束，并阻塞等待；如果调用继承的 Quit 方法，则只会结束消息队列循环，而不会结束线程</span></span><br><span class="line">  <span class="comment">// 注意：一定不要在线程内部调用此方法    </span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认情况下，将调用 ProcessMessages(kForever),如果要做其它工作，则需要重写 Run()</span></span><br><span class="line">  <span class="comment">// 如果需要接受或者处理消息，则需要自己主动调用 ProcessMessages 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向消息队列发消息，并阻塞等待其执行完毕</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">(<span class="keyword">const</span> Location&amp; posted_from,</span></span></span><br><span class="line"><span class="function"><span class="params">                    MessageHandler* phandler,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">uint32_t</span> id = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    MessageData* pdata = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在其它线程保证某方法被此线程调用，相当于消息的异步通知，即 POST</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ReturnT</span>, <span class="title">class</span> <span class="title">FunctorT</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">ReturnT</span> <span class="title">Invoke</span>(<span class="title">const</span> <span class="title">Location</span>&amp; <span class="title">posted_from</span>, <span class="title">const</span> <span class="title">FunctorT</span>&amp; <span class="title">functor</span>) &#123;</span></span><br><span class="line">    FunctorMessageHandler&lt;ReturnT, FunctorT&gt; handler(functor);</span><br><span class="line">    InvokeInternal(posted_from, &amp;handler);</span><br><span class="line">    <span class="keyword">return</span> handler.MoveResult();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 继承与 MessageQueue</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">(MessageHandler* phandler,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">uint32_t</span> id = MQID_ANY,</span></span></span><br><span class="line"><span class="function"><span class="params">             MessageList* removed = <span class="literal">nullptr</span>)</span> override</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReceiveSends</span><span class="params">()</span> override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ProcessMessages will process I/O and dispatch messages until:</span></span><br><span class="line">  <span class="comment">//  1) cms milliseconds have elapsed (returns true)</span></span><br><span class="line">  <span class="comment">//  2) Stop() is called (returns false)</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ProcessMessages</span><span class="params">(<span class="keyword">int</span> cms)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断此线程是否是我们自己通过标准的构造函数进行创建的，如果是就返回 true</span></span><br><span class="line">  <span class="comment">// 如果是通过 ThreadManager::WrapCurrentThread() 创建的则返回 false</span></span><br><span class="line">  <span class="comment">// 不能对 IsOwned 返回 false 线程对象调用 Start</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsOwned</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取平台相关的线程句柄和 Id</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WEBRTC_WIN)</span></span><br><span class="line">  <span class="function">HANDLE <span class="title">GetHandle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> thread_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">DWORD <span class="title">GetId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> thread_id_;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(WEBRTC_POSIX)</span></span><br><span class="line">  <span class="keyword">pthread_t</span> GetPThread() &#123;</span><br><span class="line">    <span class="keyword">return</span> thread_;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Expose private method running() for tests.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// DANGER: this is a terrible public API.  Most callers that might want to</span></span><br><span class="line">  <span class="comment">// call this likely do not have enough control/knowledge of the Thread in</span></span><br><span class="line">  <span class="comment">// question to guarantee that the returned value remains true for the duration</span></span><br><span class="line">  <span class="comment">// of whatever code is conditionally executing because of the return value!</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">RunningForTest</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> running(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sets the per-thread allow-blocking-calls flag and returns the previous</span></span><br><span class="line">  <span class="comment">// value. Must be called on this thread.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SetAllowBlockingCalls</span><span class="params">(<span class="keyword">bool</span> allow)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// These functions are public to avoid injecting test hooks. Don't call them</span></span><br><span class="line">  <span class="comment">// outside of tests.</span></span><br><span class="line">  <span class="comment">// This method should be called when thread is created using non standard</span></span><br><span class="line">  <span class="comment">// method, like derived implementation of rtc::Thread and it can not be</span></span><br><span class="line">  <span class="comment">// started by calling Start(). This will set started flag to true and</span></span><br><span class="line">  <span class="comment">// owned to false. This must be called from the current thread.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">WrapCurrent</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">UnwrapCurrent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// Same as WrapCurrent except that it never fails as it does not try to</span></span><br><span class="line">  <span class="comment">// acquire the synchronization access of the thread. The caller should never</span></span><br><span class="line">  <span class="comment">// call Stop() or Join() on this thread.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SafeWrapCurrent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Blocks the calling thread until this thread has terminated.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Join</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AssertBlockingIsAllowedOnCurrentThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopedDisallowBlockingCalls</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ThreadInit</span> &#123;</span></span><br><span class="line">    Thread* thread;</span><br><span class="line">    Runnable* runnable;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WEBRTC_WIN)</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> DWORD WINAPI <span class="title">PreRun</span><span class="params">(LPVOID context)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">PreRun</span><span class="params">(<span class="keyword">void</span> *pv)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ThreadManager calls this instead WrapCurrent() because</span></span><br><span class="line">  <span class="comment">// ThreadManager::Instance() cannot be used while ThreadManager is</span></span><br><span class="line">  <span class="comment">// being created.</span></span><br><span class="line">  <span class="comment">// The method tries to get synchronization rights of the thread on Windows if</span></span><br><span class="line">  <span class="comment">// |need_synchronize_access| is true.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">WrapCurrentWithThreadManager</span><span class="params">(ThreadManager* thread_manager,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">bool</span> need_synchronize_access)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if the thread was started and hasn't yet stopped.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">running</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> running_.Wait(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Processes received "Send" requests. If |source| is not null, only requests</span></span><br><span class="line">  <span class="comment">// from |source| are processed, otherwise, all requests are processed.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReceiveSendsFromThread</span><span class="params">(<span class="keyword">const</span> Thread* source)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If |source| is not null, pops the first "Send" message from |source| in</span></span><br><span class="line">  <span class="comment">// |sendlist_|, otherwise, pops the first "Send" message of |sendlist_|.</span></span><br><span class="line">  <span class="comment">// The caller must lock |crit_| before calling.</span></span><br><span class="line">  <span class="comment">// Returns true if there is such a message.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">PopSendMessageFromThread</span><span class="params">(<span class="keyword">const</span> Thread* source, _SendMessage* msg)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">InvokeInternal</span><span class="params">(<span class="keyword">const</span> Location&amp; posted_from, MessageHandler* handler)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;_SendMessage&gt; sendlist_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">  Event running_;  <span class="comment">// Signalled means running.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WEBRTC_POSIX)</span></span><br><span class="line">  <span class="keyword">pthread_t</span> thread_;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WEBRTC_WIN)</span></span><br><span class="line">  HANDLE thread_;</span><br><span class="line">  DWORD thread_id_;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> owned_;</span><br><span class="line">  <span class="keyword">bool</span> blocking_calls_allowed_;  <span class="comment">// By default set to |true|.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadManager</span>;</span></span><br><span class="line"></span><br><span class="line">  RTC_DISALLOW_COPY_AND_ASSIGN(Thread);  <span class="comment">// 禁用拷贝构造和操作运算符 =</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><ul><li>创建实例</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;rtc::Thread&gt; _worker_thread_ptr(<span class="built_in">std</span>::move(rtc::Thread::CreateWithSocketServer()));</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;rtc::Thread&gt; _signal_thread_ptr(<span class="built_in">std</span>::move(rtc::Thread::CreateWithSocketServer()));</span><br><span class="line">_worker_thread_ptr-&gt;Start();</span><br><span class="line">_signal_thread_ptr-&gt;Start();</span><br><span class="line">......</span><br><span class="line">_worker_thread_ptr-&gt;Stop();</span><br><span class="line">_signal_thread_ptr-&gt;Stop();</span><br></pre></td></tr></table></figure><ul><li>创建音频模块 ADM</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rtc::scoped_refptr&lt;webrtc::AudioDeviceModule&gt; _adm_ptr =</span><br><span class="line">    _worker_thread_ptr-&gt;Invoke&lt;rtc::scoped_refptr&lt;webrtc::AudioDeviceModule&gt;&gt;(RTC_FROM_HERE, [] &#123;</span><br><span class="line">        <span class="comment">//create adm</span></span><br><span class="line">        <span class="keyword">return</span> webrtc::AudioDeviceModule::Create(<span class="number">0</span>,</span><br><span class="line">            webrtc::AudioDeviceModule::AudioLayer::kWindowsCoreAudio);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><ul><li>创建 PC 工厂类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rtc::scoped_refptr&lt;webrtc::PeerConnectionFactoryInterface&gt; _peerconn_factory_ptr = webrtc::CreatePeerConnectionFactory(</span><br><span class="line">        _worker_thread_ptr.get(), _worker_thread_ptr.get(), _signal_thread_ptr.get(), _adm_ptr, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebRTC::Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常用命令备忘录</title>
      <link href="/posts/2785101152.html"/>
      <url>/posts/2785101152.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录 Linux 常用命令</p></blockquote><h2 id="常看实时网速"><a href="#常看实时网速" class="headerlink" title="常看实时网速"></a>常看实时网速</h2><pre><code>- nethogs: 按进程查看流量占用- iptraf: 按连接/端口查看流量- ifstat: 按设备查看流量- ethtool: 诊断工具- tcpdump: 抓包工具- ss: 连接查看工具其他: dstat, slurm, nload, bmon简单的建议就是使用 ifstat，输入命令，直接就列出所有网卡的实时网速；ss 命令可以查看当前所有的连接，类似 netstat，但是更加方便；</code></pre><h2 id="screen-管理远程会话连接"><a href="#screen-管理远程会话连接" class="headerlink" title="screen 管理远程会话连接"></a>screen 管理远程会话连接</h2><p>###语法</p><h4 id="screen-AmRvx-ls-wipe-d-lt-作业名称-gt-h-lt-行数-gt-r-lt-作业名称-gt-s-S-lt-作业名称-gt"><a href="#screen-AmRvx-ls-wipe-d-lt-作业名称-gt-h-lt-行数-gt-r-lt-作业名称-gt-s-S-lt-作业名称-gt" class="headerlink" title="screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]"></a>screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]</h4><p>参数说明</p><p>-A 　将所有的视窗都调整为目前终端机的大小。</p><p>-d &lt;作业名称&gt; 　将指定的screen作业离线。</p><p>-h &lt;行数&gt; 　指定视窗的缓冲区行数。</p><p>-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。</p><p>-r &lt;作业名称&gt; 　恢复离线的screen作业。</p><p>-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。</p><p>-s 　指定建立新视窗时，所要执行的shell。</p><p>-S &lt;作业名称&gt; 　指定screen作业的名称。</p><p>-v 　显示版本信息。</p><p>-x 　恢复之前离线的screen作业。</p><p>-ls或–list 　显示目前所有的screen作业。</p><p>-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。</p><h3 id="常用screen参数"><a href="#常用screen参数" class="headerlink" title="常用screen参数"></a>常用screen参数</h3><p><a href="http://blog.csdn.net/zy_zhengyang/article/details/52385887" target="_blank" rel="noopener">参考网址</a></p><p>screen -S yourname -&gt; 新建一个叫yourname的session</p><p>screen -ls -&gt; 列出当前所有的session</p><p>screen -r yourname -&gt; 回到yourname这个session</p><p>screen -d yourname -&gt; 远程detach某个session</p><p>screen -d -r yourname -&gt; 结束当前session并回到yourname这个session</p><p>在每个screen session 下，所有命令都以 ctrl+a(C-a) 开始。</p><p>C-a ? -&gt; 显示所有键绑定信息</p><p>C-a c -&gt; 创建一个新的运行shell的窗口并切换到该窗口</p><p>C-a n -&gt; Next，切换到下一个 window </p><p>C-a p -&gt; Previous，切换到前一个 window </p><p>C-a 0..9 -&gt; 切换到第 0..9 个 window</p><p>Ctrl+a [Space] -&gt; 由视窗0循序切换到视窗9</p><p>C-a C-a -&gt; 在两个最近使用的 window 间切换 </p><p>C-a x -&gt; 锁住当前的 window，需用用户密码解锁</p><p>C-a d -&gt; detach，暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响。 </p><p>C-a z -&gt; 把当前session放到后台执行，用 shell 的 fg 命令则可回去。</p><p>C-a w -&gt; 显示所有窗口列表</p><p>C-a t -&gt; Time，显示当前时间，和系统的 load </p><p>C-a k -&gt; kill window，强行关闭当前的 window</p><p>C-a [ -&gt; 进入 copy mode，在 copy mode 下可以回滚、搜索、复制就像用使用 vi 一样</p><pre><code>C-b Backward，PageUp C-f Forward，PageDown H(大写) High，将光标移至左上角 L Low，将光标移至左下角 0 移到行首 $ 行末 w forward one word，以字为单位往前移 b backward one word，以字为单位往后移 Space 第一次按为标记区起点，第二次按为终点 Esc 结束 copy mode </code></pre><p>C-a ] -&gt; Paste，把刚刚在 copy mode 选定的内容贴上</p><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>查看系统配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure></p><p>查看当前用户 Git 配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure></p><p>查看当前仓库配置信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list</span><br></pre></td></tr></table></figure></p><p>配置用户名密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;myname&quot;</span><br><span class="line">git config --global user.email  &quot;test@gmail.com&quot;</span><br></pre></td></tr></table></figure></p><p>生成 ssh key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></p><p>public key 文件为 ：<code>~/.ssh/id_rsa.pub</code>；</p><p>添加到 github 的 ssh key 中后，测试命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T ssh@github.com</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解决 WebRTC 花屏问题记录</title>
      <link href="/posts/157760719.html"/>
      <url>/posts/157760719.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>现象：WebRTC native 层经常打印 <code>Failed to unprotect SRTP packet, err=9</code>，订阅端会出现部分绿屏、花屏的情况，严重影响视频通话体验。</p></blockquote><h1 id="情景描述"><a href="#情景描述" class="headerlink" title="情景描述"></a>情景描述</h1><p>当前基于 WebRTC 开发自己的音视频实时通话的产品，服务器选择了 licode，在多端 H5、Android、iOS、C++ Native 端均有一定的概率会出现绿屏、花屏的现象，特别是在弱网下出现的概率更高；</p><p>在出现绿屏、花屏时，native log 也会经常输出的 <code>Failed to unprotect SRTP packet, err=9</code> log，花屏时，或者完全无法播放（有流量，但无画面），此 <code>Failed to unprotect SRTP packet, err=9</code> log 出现的概率更高；</p><p>当前已排除不同订阅终端在同一房间内跨运营商的网络问题，但依然会存在此类问题；</p><p>RTP/RTCP</p><ul><li><p>SR（Sender Report） 发送端报告</p></li><li><p>RR（Receiver Report）接收端报告</p></li><li><p>REMB (Receiver Estimated Maximum Bitrate)</p><p>接收端最大接收码率估测，接收端会估计本地接收的最大带宽能力，并通过RTCP REMB 消息返回给对端，这样对端可以调整自己的发送端码率，达到动态调整带宽的目的，具体消息类型通过rtcp的属性 <code>Unique identifier</code> 来区分是 <code>REMG</code> 消息，此部分是四个字节，</p></li></ul><p>REMG 信令协商：webrtc里面的协商格式是：<code>a=rtcp-fb:100 goog-remb，100 是codec payload</code>; 这里goog 实际上是 google 实现了自己版本的remb。</p><ul><li><p>GCC 码率估计算法（接收端），用来生成 <code>REMG</code> 包</p></li><li><p>TMMBR（Temporal Max Media Bitrate Request），表示临时最大码率请求。表明接收端当前带宽受限，告诉发送端控制码率。</p></li><li><p>TMMBN（Temporal Max Media Bitrate Notification）临时最大码率通知。</p></li><li><p>SDES 源描述，主要功能是作为会话成员有关标识信息的载体，如用户名、邮件地址、电话号码等，此外还具有向会话成员传达会话控制信息的功能。</p></li><li><p>BYE　通知离开，主要功能是指示某一个或者几个源不再有效，即通知会话中的其他成员自己将退出会话。</p></li><li><p>APP　由应用程序自己定义，解决了RTCP的扩展性问题，并且为协议的实现者提供了很大的灵活性。</p></li></ul><p><strong>关键帧请求</strong></p><ul><li><p>PLI（Picture Loss Indication）</p></li><li><p>SLI（Slice Loss Indication）</p></li></ul><p>发送方接收到接收方反馈的PLI或SLI需要重新让编码器生成关键帧并发送给接收端。</p><ul><li>FIR（Full Intra Request）</li></ul><p>这里面 Intra 的含义是图像内编码，不需要其他图像信息即可解码；Inter 指图像间编码，解码需要参考帧。所以 Intra Frame 其实就是指 I 帧，Inter Frame指 P 帧或 B 帧。</p><blockquote><p>那么为什么在 PLI 和 SLI 之外还需要一个 FIR 呢？<br>原因是使用场景不同，FIR 更多是在一个中心化的 Video Conference 中，新的参与者加入，就需要发送一个 FIR，其他的参与者给他发送一个关键帧这样才能解码，而 PLI 和 SLI 的含义更多是在发生丢包或解码错误时使用。</p></blockquote><p><strong>重传请求</strong></p><ul><li>RTX／NACK／RPSI</li></ul><p>这个重传跟关键帧请求的区别是它可以要求任意帧进行重传;</p><ul><li><p>RED（redundant packet）冗余包，配合 FEC 使用。</p></li><li><p>FEC 前向纠错算法，经 FEC 算法计算后，通过 RED 生成冗余包。</p></li><li><p>SRTP 详解 <a href="http://blog.csdn.net/ljinddlj/article/details/3912747" target="_blank" rel="noopener">参考 ULR</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> RTC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BOOST 在 Windows 下通过 VS 进行编译</title>
      <link href="/posts/827497819.html"/>
      <url>/posts/827497819.html</url>
      
        <content type="html"><![CDATA[<h1 id="下载-Boost-源码"><a href="#下载-Boost-源码" class="headerlink" title="下载 Boost 源码"></a>下载 Boost 源码</h1><p>从官方下载 Boost 源码，之前用的一直是 boost 1.58.0，今天去官方网站看到最新的已经是 boost 1.66.0，最新版本的下载地址是：<a href="https://akamai.bintray.com/59/596389389c005814ecb2a6b64c31dccd2c3e6fbc5a802b4dfada999ae5844628?__gda__=exp=1520835412~hmac=6d6c97450b9b0b9421f696c922c483f87493fe9a10890fc7235a1c30c120f8e1&amp;response-content-disposition=attachment%3Bfilename%3D%22boost_1_66_0.7z%22&amp;response-content-type=application%2Fx-7z-compressed&amp;requestInfo=U2FsdGVkX19TK62uO_jw5nC8JAtKkRu4cX28_lg3Z3y4xQkcbs9DqFSaTA0PDQKfCQ9Q94pRYGu60LzIyLyeN5mNvuokt1GI_MdVPpMBQLpNhTWhePsfBOrGtyhg6MOCF0JFr3mSugB0Sihk9fO5Wr1BR4MLQS9n78rtxF7JwNmR7sZ6on6X6jtu9UTYTMBy&amp;response-X-Checksum-Sha1=075d0b43980614054b1f1bafd189f863bba6600e&amp;response-X-Checksum-Sha2=596389389c005814ecb2a6b64c31dccd2c3e6fbc5a802b4dfada999ae5844628" target="_blank" rel="noopener">下载地址</a></p><p>建议使用迅雷进行下载，通过浏览器下的比较慢。<br>下载后解压到自己的开源项目目录下，如：<code>E:\OpenSource\boost_1_66_0</code></p><h1 id="Windows-下通过-Visual-Studio-2015-编译"><a href="#Windows-下通过-Visual-Studio-2015-编译" class="headerlink" title="Windows 下通过 Visual Studio 2015 编译"></a>Windows 下通过 Visual Studio 2015 编译</h1><p>启动 VS2015 的 X86 本机工具命令提示符，即 <code>VS2015 x86 Native Tools Command Prompt</code> ，进入 boost 源码目录：<code>E:\OpenSource\boost_1_66_0</code>，然后执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.bat   //首先执行此命令生成 b2 编译工具</span><br><span class="line">bjam stage --toolset=msvc-14.0 --without-graph --without-graph_parallel --stagedir=&quot;D:\boost\boost_1_63_0\bin\vc14&quot; link=static runtime-link=static runtime-link=static threading=multi debug release</span><br></pre></td></tr></table></figure><p>以上命令生成 32bit 静态库；如果希望生成 64bit，则使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bjam stage --toolset=msvc-14.0 architecture=x86 address-model=64 --without-graph --without-graph_parallel --stagedir=&quot;D:\boost\boost_1_63_0\bin\vc14-x64&quot; link=static runtime-link=static runtime-link=static threading=multi debug release</span><br></pre></td></tr></table></figure></p><h1 id="相关编译选项"><a href="#相关编译选项" class="headerlink" title="相关编译选项"></a>相关编译选项</h1><p>下面详细解释一下每个参数的含义：</p><ul><li><p>stage/install：<br>stage表示只生成库（dll和lib），install还会生成包含头文件的include目录。本人推荐使用stage，因为install生成的这个include目录实际就是boost安装包解压缩后的boost目录（<code>E:\OpenSource\boost_1_66_0\boost</code>，只比include目录多几个非hpp文件，都很小），所以可以直接使用，而且不同的IDE都可以使用同一套头文件，这样既节省编译时间，也节省硬盘空间。</p></li><li><p>toolset：<br>指定编译器，可选的如borland、gcc、msvc（VC6）、msvc-14.0（VS2015）等。</p></li><li><p>without/with：<br>选择不编译/编译哪些库。因为python、mpi等库我都用不着，所以排除之。还有wave、graph、math、regex、test、program_options、serialization、signals这几个库编出的静态lib都非常大，所以不需要的也可以without掉。这可以根据各人需要进行选择，默认是全部编译。但是需要注意，如果选择编译python的话，是需要python语言支持的，应该到 python <a href="http://www.python.org/" target="_blank" rel="noopener">官方主页</a>下载安装。查看boost包含库的命令是bjam –show-libraries。</p></li><li><p>stagedir/prefix：<br>stage时使用stagedir，install时使用prefix，表示编译生成文件的路径。推荐给不同的IDE指定不同的目录。</p></li><li><p>build-dir：编译生成的中间文件的路径。这个本人这里没用到，默认就在根目录（<code>E:\OpenSource\boost_1_66_0</code>）下，目录名为bin.v2，等编译完成后可将这个目录全部删除（没用了），所以不需要去设置。</p></li><li><p>link：<br>生成动态链接库/静态链接库。生成动态链接库需使用shared方式，生成静态链接库需使用static方式。一般boost库可能都是以static方式编译，因为最终发布程序带着boost的dll感觉会比较累赘。</p></li><li><p>runtime-link：<br>动态/静态链接C/C++运行时库。同样有shared和static两种方式，这样runtime-link和link一共可以产生4种组合方式，各人可以根据自己的需要选择编译。一般link只选static的话，只需要编译2种组合即可，即link=static runtime-link=shared和link=static runtime-link=static，本人一般就编这两种组合。</p></li><li><p>threading：<br>单/多线程编译。一般都写多线程程序，当然要指定multi方式了；如果需要编写单线程程序，那么还需要编译单线程库，可以使用single方式。</p></li><li><p>debug/release：<br>编译debug/release版本。一般都是程序的debug版本对应库的debug版本，所以两个都编译。</p></li><li><p>address-model=32/64<br>寻址模式(生成32位还是64位库)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 开源日志库 spdlog</title>
      <link href="/posts/1178514105.html"/>
      <url>/posts/1178514105.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-日志组件-spdlog"><a href="#C-日志组件-spdlog" class="headerlink" title="C++日志组件 spdlog"></a>C++日志组件 spdlog</h1><p><code>spdlog</code> 是基于C++ 11的开源的轻量级的日志组件，引入也非常简单，仅仅需要引入头文件就可以了。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>命名空间 <code>spdlog</code> 之下的大多数函数都是线程安全的，除了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> spdlog::set_pattern(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br><span class="line"><span class="keyword">void</span> spdlog::set_formatter(formatter_ptr);</span><br><span class="line"><span class="keyword">void</span> spdlog::set_error_handler(log_err_handler);</span><br></pre></td></tr></table></figure></p><p>日志器对象的大部分方法也是线程安全的，除了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> spdlog::logger::set_pattern(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br><span class="line"><span class="keyword">void</span> spdlog::logger::set_formatter(formatter_ptr);</span><br><span class="line"><span class="keyword">void</span> spdlog::set_error_handler(log_err_handler);</span><br></pre></td></tr></table></figure></p><p>所有以 <code>_mt</code> 结尾的 Sink 都是用于多线程的，以 <code>_st</code> 结尾的则是用于单线程的，不过现在单线程的程序很少了吧，建议直接用以 <code>_mt</code> 结尾的多线程安全的日志对象；</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"spdlog/spdlog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 多线程的基于控制台（stdout）的日志记录器，支持高亮。类似的stdout_color_st是单线程版本</span></span><br><span class="line"><span class="keyword">auto</span> console = spdlog::stdout_color_mt( <span class="string">"console"</span> );</span><br><span class="line"><span class="comment">// 基于文件的简单日志</span></span><br><span class="line"><span class="keyword">auto</span> logger = spdlog::basic_logger_mt(<span class="string">"basic_logger"</span>, <span class="string">"logs/basic.txt"</span>);</span><br><span class="line"><span class="comment">// 基于滚动文件的日志，每个文件5MB，三个文件</span></span><br><span class="line"><span class="keyword">auto</span> logger = spdlog::rotating_logger_mt(<span class="string">"file_logger"</span>, <span class="string">"myfilename"</span>, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定制输出格式</span></span><br><span class="line">spdlog::set_pattern(<span class="string">"*** [%H:%M:%S %z] [thread %t] %v ***"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 多个日志器共享SINK</span></span><br><span class="line"><span class="keyword">auto</span> daily_sink = <span class="built_in">std</span>::make_shared&lt;spdlog::sinks::daily_file_sink_mt&gt;(<span class="string">"logfile"</span>, <span class="number">23</span>, <span class="number">59</span>);</span><br><span class="line"><span class="comment">// 下面几个同步日志器共享的输出到目标文件</span></span><br><span class="line"><span class="keyword">auto</span> net_logger = <span class="built_in">std</span>::make_shared&lt;spdlog::logger&gt;(<span class="string">"net"</span>, daily_sink);</span><br><span class="line"><span class="keyword">auto</span> hw_logger = <span class="built_in">std</span>::make_shared&lt;spdlog::logger&gt;(<span class="string">"hw"</span>, daily_sink);</span><br><span class="line"><span class="keyword">auto</span> db_logger = <span class="built_in">std</span>::make_shared&lt;spdlog::logger&gt;(<span class="string">"db"</span>, daily_sink); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 一个日志器使用多个SINK</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;spdlog::sink_ptr&gt; sinks;</span><br><span class="line">sinks.push_back( <span class="built_in">std</span>::make_shared&lt;spdlog::sinks::stdout_sink_st&gt;());</span><br><span class="line">sinks.push_back( <span class="built_in">std</span>::make_shared&lt;spdlog::sinks::daily_file_sink_st&gt;( <span class="string">"logfile"</span>, <span class="number">23</span>, <span class="number">59</span> ));</span><br><span class="line"><span class="keyword">auto</span> combined_logger = <span class="built_in">std</span>::make_shared&lt;spdlog::logger&gt;( <span class="string">"name"</span>, begin( sinks ), end( sinks ));</span><br><span class="line">spdlog::register_logger( combined_logger );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line"><span class="comment">// 每个日志器分配8192长度的队列，队列长度必须2的幂</span></span><br><span class="line">spdlog::set_async_mode(<span class="number">8192</span>); </span><br><span class="line"><span class="comment">// 程序退出前清理</span></span><br><span class="line">spdlog::drop_all();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 注册日志器</span></span><br><span class="line">spdlog::register_logger(net_logger);</span><br><span class="line"><span class="comment">// 注册后，其它代码可以根据名称获得日志器</span></span><br><span class="line"><span class="keyword">auto</span> logger = spdlog::get(net_logger);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 记录日志</span></span><br><span class="line"><span class="comment">// 设置最低级别</span></span><br><span class="line">console-&gt;set_level(spdlog::level::debug);</span><br><span class="line">console-&gt;debug(<span class="string">"Hello World"</span>) ;</span><br><span class="line"><span class="comment">// 使用占位符</span></span><br><span class="line">console-&gt;info(<span class="string">"Hello &#123;&#125;"</span> ,<span class="string">"World"</span>); </span><br><span class="line"><span class="comment">// 带格式化的占位符：d整数，x十六进制，o八进制，b二进制                </span></span><br><span class="line">console-&gt;warn(<span class="string">"Support for int: &#123;0:d&#125;; hex: &#123;0:x&#125;; oct: &#123;0:o&#125;; bin: &#123;0:b&#125;"</span>, <span class="number">42</span>);</span><br><span class="line"><span class="comment">// 带格式化的占位符：f浮点数</span></span><br><span class="line">console-&gt;info(<span class="string">"Support for floats &#123;:03.2f&#125;"</span>, <span class="number">1.23456</span>);</span><br><span class="line"><span class="comment">// 左对齐，保证30字符宽度</span></span><br><span class="line">console-&gt;error(<span class="string">"&#123;:&lt;30&#125;"</span>, <span class="string">"left aligned"</span>);</span><br><span class="line"><span class="comment">// 指定占位符位置序号</span></span><br><span class="line">console-&gt;info(<span class="string">"Positional args are &#123;1&#125; &#123;0&#125;.."</span>, <span class="string">"too"</span>, <span class="string">"supported"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 记录自定义类型，需要重载&lt;&lt;操作符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;spdlog/fmt/ostr.h&gt; </span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>&#123;</span>&#125;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> Duck&amp; duck)&#123; </span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; duck.getName(); </span><br><span class="line">&#125;</span><br><span class="line">Duck duck;</span><br><span class="line">console-&gt;info(<span class="string">"custom class with operator&lt;&lt;: &#123;&#125;.."</span>, duck);</span><br></pre></td></tr></table></figure><p>输出格式</p><p>spdlog默认的输出格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2018-03-01 23:46:59.678] [info] [my_loggername] Some message</span><br></pre></td></tr></table></figure></p><p>要定制输出格式，可以调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//估计大部分人都喜欢下面这样的格式输出格式：</span></span><br><span class="line">spdlog::set_pattern(<span class="string">"[%Y-%m-%d %H:%M:%S.%e][%t][%l] %v"</span>);</span><br><span class="line"><span class="comment">//或者实现自己的格式化器：</span></span><br><span class="line">spdlog::set_formatter(<span class="built_in">std</span>::make_shared&lt;my_custom_formatter&gt;());</span><br></pre></td></tr></table></figure></p><p>输出格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2018-03-01 23:28:04.285][13464][info] Input host name:gobert, ptr:0x9c6a78</span><br></pre></td></tr></table></figure></p><p>Pattern 格式说明</p><p>输出格式的 Pattern 中可以有若干 <code>%</code> 开头的标记，含义如下表：</p><table><thead><tr><th>标记</th><th>说明</th></tr></thead><tbody><tr><td>%v</td><td>实际需要被日志记录的文本，如果文本中有{占位符}会被替换</td></tr><tr><td>%t</td><td>线程标识符</td></tr><tr><td>%P</td><td>进程标识符</td></tr><tr><td>%n</td><td>日志记录器名称</td></tr><tr><td>%l</td><td>日志级别</td></tr><tr><td>%L</td><td>日志级别简写</td></tr><tr><td>%a</td><td>简写的周几，例如Thu</td></tr><tr><td>%A</td><td>周几，例如Thursday</td></tr><tr><td>%b</td><td>简写的月份，例如Aug</td></tr><tr><td>%B</td><td>月份，例如August</td></tr><tr><td>%c</td><td>日期时间，例如Thu Aug 23 15:35:46 2014</td></tr><tr><td>%C</td><td>两位年份，例如14</td></tr><tr><td>%Y</td><td>四位年份，例如2014</td></tr><tr><td>%D 或 %x</td><td>MM/DD/YY格式日期，例如”08/23/14</td></tr><tr><td>%m</td><td>月份，1-12之间</td></tr><tr><td>%d</td><td>月份中的第几天，1-31之间</td></tr><tr><td>%H</td><td>24小时制的小时，0-23之间</td></tr><tr><td>%I</td><td>12小时制的小时，1-12之间</td></tr><tr><td>%M</td><td>分钟，0-59</td></tr><tr><td>%S</td><td>秒，0-59</td></tr><tr><td>%e</td><td>当前秒内的毫秒，0-999</td></tr><tr><td>%f</td><td>当前秒内的微秒，0-999999</td></tr><tr><td>%F</td><td>当前秒内的纳秒， 0-999999999</td></tr><tr><td>%p</td><td>AM或者PM</td></tr><tr><td>%r</td><td>12小时时间，例如02:55:02 pm</td></tr><tr><td>%R</td><td>等价于%H:%M，例如23:55</td></tr><tr><td>%T 或 %X</td><td>HH:MM:SS</td></tr><tr><td>%z</td><td>时区UTC偏移，例如+02:00</td></tr><tr><td>%+</td><td>表示默认格式</td></tr></tbody></table><h2 id="个人实战应用源码"><a href="#个人实战应用源码" class="headerlink" title="个人实战应用源码"></a>个人实战应用源码</h2><p>根据个人的习惯，喜欢在开发后端程序时，喜欢将 log 同时输出到控制台和文件中，那么根据 spdlog 的接口，需要在创建对象时将 console 和 file sink 均传入即可，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spdlog::set_async_mode(<span class="number">4096</span>);</span><br><span class="line">spdlog::set_pattern(<span class="string">"[%Y-%m-%d %H:%M:%S.%e][%t][%l] %v"</span>);</span><br><span class="line"><span class="comment">//创建控制台对象指针</span></span><br><span class="line"><span class="keyword">auto</span> console_log_ptr = spdlog::stdout_logger_mt(<span class="string">"console"</span>);</span><br><span class="line"><span class="comment">//创建文件对象指针</span></span><br><span class="line"><span class="keyword">auto</span> file_log_ptr = spdlog::rotating_logger_mt(<span class="string">"file"</span>, <span class="string">"opc-collector.log"</span>, <span class="number">100</span> * <span class="number">1024</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//将以上两种日志对象 sink 组合在一起</span></span><br><span class="line">spdlog::sinks_init_list sink_list = &#123; console_log_ptr-&gt;sinks().front(), file_log_ptr-&gt;sinks().front() &#125;;</span><br><span class="line"><span class="comment">//创建一个新的日志对象，以上面两个日志对象作为初始化参数，即实现了同时输出 console 和 file</span></span><br><span class="line"><span class="keyword">auto</span> log_ptr = spdlog::create(<span class="string">"loggername"</span>, sink_list);</span><br><span class="line"></span><br><span class="line">log_ptr-&gt;info(<span class="string">"Test spdlog output:string:&#123;&#125;, int:&#123;&#125;"</span>, <span class="string">"spdlog info test string"</span>, <span class="number">123456</span>);</span><br><span class="line">log_ptr-&gt;flush();</span><br></pre></td></tr></table></figure><p><strong>注：将多个日志对象同时输出到一个日志对象时，其 loggername 不能保持一致，否则报错警告称：loggername 重复！</strong></p><p>以上内容大部分参考自：<a href="https://blog.gmem.cc/spdlog" target="_blank" rel="noopener">https://blog.gmem.cc/spdlog</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10 安装 .NetFrameWork 3.5</title>
      <link href="/posts/3530668087.html"/>
      <url>/posts/3530668087.html</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-10-下安装-NetFrameWork-3-5"><a href="#Windows-10-下安装-NetFrameWork-3-5" class="headerlink" title="Windows 10 下安装 .NetFrameWork 3.5"></a>Windows 10 下安装 .NetFrameWork 3.5</h1><p>某些软件依赖.NetFrameWork 3.5,但是通过系统自带的 <code>启动或关闭 Windows 功能</code>的界面接口去添加 .NetFrameWork 3.5 会失败，即使先删除了 .NetFrameWork 4.7 也是会失败，比如会报如下一些错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x800F0906</span><br><span class="line">0x800F081F</span><br><span class="line">0x800F0907</span><br><span class="line">0x800F0922</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>现总结如下安装方法;</p><h2 id="下载-NetFrameWork-3-5-离线安装包"><a href="#下载-NetFrameWork-3-5-离线安装包" class="headerlink" title="下载 .NetFrameWork 3.5 离线安装包"></a>下载 .NetFrameWork 3.5 离线安装包</h2><p><a href="https://d11.baidupcs.com/file/f035714091c087774ca76a254018be04?bkt=p3-000014508cb2b9cb0151cee0f9ed3c6b0021&amp;xcode=7cbd07a2b4f6f74a3477739bc86162007cbccbd369afad2e710b2321bcd8d2e5e4b423467a61eb46&amp;fid=2098421940-250528-207166886389709&amp;time=1519614793&amp;sign=FDTAXGERLQBHSKa-DCb740ccc5511e5e8fedcff06b081203-kspSbRcHERbGt4GGM8ncJm%2B0M%2F8%3D&amp;to=d11&amp;size=72329390&amp;sta_dx=72329390&amp;sta_cs=70095&amp;sta_ft=cab&amp;sta_ct=7&amp;sta_mt=7&amp;fm2=MH%2CYangquan%2CAnywhere%2C%2Cshanghai%2Cct&amp;vuk=282335&amp;iv=0&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=000014508cb2b9cb0151cee0f9ed3c6b0021&amp;sl=79364174&amp;expires=8h&amp;rt=sh&amp;r=512254481&amp;mlogid=1309641164889007677&amp;vbdid=2429812664&amp;fin=NetFx3.cab&amp;fn=NetFx3.cab&amp;rtype=1&amp;dp-logid=1309641164889007677&amp;dp-callid=0.1.1&amp;hps=1&amp;tsl=100&amp;csl=100&amp;csign=azJdY%2B10Z49b0LbASthGmxMFU9c%3D&amp;so=0&amp;ut=6&amp;uter=4&amp;serv=0&amp;uc=1415919733&amp;ic=69126377&amp;ti=f8fdaa4589ff2f184c4630f76c465917b1fcaab7023e5652&amp;by=themis" target="_blank" rel="noopener">下载地址</a></p><p>下载完成后，将此文件 <code>NetFx3.cab</code> 不要解压直接拷贝到 <code>C:/Windows</code> 目录下;</p><h2 id="命令安装"><a href="#命令安装" class="headerlink" title="命令安装"></a>命令安装</h2><p>以管理员权限运行 cmd 命令，执行以下命令直至 100% 成功即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:netfx3 /Source:L:\sources\sxs</span><br></pre></td></tr></table></figure></p><h2 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h2><p>如果不出问题的话是可以安装成功的，且不用重启，这时打开控制面板中 <code>启动或关闭 Windows 功能</code> 的界面，可以看到 <code>.Net FrameWork 3.5</code> 已经安装成功了，这时勾选 <code>.Net FrameWork 4.7</code> 并确定，以免其它已安装的依赖软件不能正常运行。</p>]]></content>
      
      
      <categories>
          
          <category> OPC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10 开发部署支持 Windows XP 和 Windows Server 2003 的应用程序</title>
      <link href="/posts/2298614161.html"/>
      <url>/posts/2298614161.html</url>
      
        <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>在 Windows 10 下通过 VS2015 开发的桌面程序，部署到 Windows Server 2003 系统中，运行不起来，运行会报 “不是有效的 Win32 应用程序” 或者是 “不能定位 XXX.XXX 到 api-ms-win-…-…-l1-1-0.dll”，这里原因有两个，一个是在编译时默认指定的平台工具集系统版本较高，另一个就是编译时依赖了只有 Windows Vista 以上版本的系统才支持的 UCRT 动态库，对此，只要按照以下方法重新编译下，即可解决低版本系统下运行的问题。</p><h1 id="解决低版本系统报错：-“不是有效的-Win32-应用程序”"><a href="#解决低版本系统报错：-“不是有效的-Win32-应用程序”" class="headerlink" title="解决低版本系统报错： “不是有效的 Win32 应用程序”"></a>解决低版本系统报错： “不是有效的 Win32 应用程序”</h1><p>将工程的平台工具集即 <code>Platform Toolset</code> 由 <code>Visual Studio 2015 (v140)</code> 改为 <code>Visual Studio 2015 - Windows XP (v140_xp)</code>；</p><p>重新编译后，通过 ExeScope 依次查看 <code>头部</code>–<code>可选头部</code>–<code>操作系统主版本</code> 发现其值为 0005，即说明该目标文件可以运行在 Windows version 为 5.0 以上的系统中了。</p><h1 id="解决-“无法定位…到-ucrt-库”"><a href="#解决-“无法定位…到-ucrt-库”" class="headerlink" title="解决 “无法定位…到 ucrt 库”"></a>解决 “无法定位…到 ucrt 库”</h1><p>VC++ 需要去除通用 CRT（UCRT）库的依赖。</p><h2 id="什么是-UCRT-库"><a href="#什么是-UCRT-库" class="headerlink" title="什么是 UCRT 库"></a>什么是 UCRT 库</h2><p>首先介绍下什么是 CRT 库：</p><p><code>C 运行时库 (CRT) 是集成了 ISO C99 标准库的 C++ 标准库。 实现 CRT 的 Visual C++ 库支持用于 .NET 开发的本机代码开发、本机和托管混合代码以及纯托管代码。 所有版本的 CRT 都支持多线程开发。 大多数的库都支持通过静态链接将库直接链接到代码中，或通过动态链接让代码使用常用 DLL 文件。</code></p><p>UCRT（通用 CRT） 包含通过标准 C99 CRT 库导出的函数和全局函数。 UCRT 现为 Windows 组件，并作为 Windows 10 的一部分提供。 静态库、DLL 导入库和 UCRT 的头文件现在 Windows 10 SDK 中提供。 安装 Visual C++ 时，Visual Studio 安装程序将安装使用 UCRT 所需 Windows 10 SDK 的子集。 可以在 Visual Studio 2015 支持的任何 Windows 版本上使用 UCRT。 可以使用 vcredist 重新分发它，以便支持 Windows 10 以外的 Windows 版本。</p><p>在 Visual Studio 2015 中，CRT 已重构为新的二进制文件。</p><p>Windows 下所有的 ucrt 库均存放在 <code>C:\Program Files (x86)\Windows Kits\10\Redist\ucrt</code> 目录下，而这些库是只有 Windows Vista 以上版本的系统才支持的，所以不能依赖此动态库，解决方法便是在编译程序时，将所有的工程的 <code>属性</code>–<code>C/C++</code>–<code>Code Generation</code>–<code>Runtime Library</code> 改为 <code>Multi-threaded (/MT)</code> 即可，重新编译后，通过 Stud_PE 查看其依赖项已经没有了 api 开发的 curt 动态库，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">api-ms-win-crt-runtime-l1-1-0.dll</span><br><span class="line">api-ms-win-crt-stdio-l1-1-0.dll</span><br><span class="line">api-ms-win-crt-math-l1-1-0.dll</span><br><span class="line">api-ms-win-crt-locale-l1-1-0.dll</span><br><span class="line">api-ms-win-crt-heap-l1-1-0.dll</span><br></pre></td></tr></table></figure></p><p><strong>注意：这里是可以将工程的运行时库编译选项改为 MT 的情况下，如果你的工程不能改为 MT 那就只能将 UCRT 库全部带上了，但是如果是 UCRT 的动态库的话，是不支持 Windows XP 和 Server 2003 一下版本的系统的！</strong></p><p>关于 CRT 库的更多的介绍，请参考微软官方的文档：<a href="https://msdn.microsoft.com/zh-cn/library/abx4dbyh.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/abx4dbyh.aspx</a></p>]]></content>
      
      
      <categories>
          
          <category> OPC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub 博客搭建记录</title>
      <link href="/posts/2377369958.html"/>
      <url>/posts/2377369958.html</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>博客搭建记录</li><li>MarkDown 如何生成文章目录</li><li>创建分类页面</li><li>创建新博文</li><li>开启统计功能</li><li>Url 去除中文</li><li>评论管理</li></ul></blockquote><h1 id="博客搭建记录"><a href="#博客搭建记录" class="headerlink" title="博客搭建记录"></a>博客搭建记录</h1><p>本文主要用于记录本博客在搭建过程中的一些细节，以免忘记！内容、格式较混乱。</p><h1 id="MarkDown-如何生成文章目录"><a href="#MarkDown-如何生成文章目录" class="headerlink" title="MarkDown 如何生成文章目录"></a>MarkDown 如何生成文章目录</h1><p>在段落中填写 <code>[TOC]</code> 既可显示全文内容的目录结构。</p><p><a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C" target="_blank" rel="noopener">Markdown 语法手册</a></p><p>本博客不支持 <code>TOC</code>。。。。</p><h1 id="创建分类页面"><a href="#创建分类页面" class="headerlink" title="创建分类页面"></a>创建分类页面</h1><p>添加一个 分类 页面，并在菜单中显示页面链接：</p><ul><li><p>新建一个页面，命名为 categories 。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure></li><li><p>编辑刚新建的页面，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2018-1-28 12:39:04</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>在菜单中添加链接。编辑主题的 _config.yml ，menu 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Menus</span><br><span class="line">menu:</span><br><span class="line">Home: /</span><br><span class="line"># Delete this row if you don&apos;t want categories in your header nav bar</span><br><span class="line">#archives: /archives</span><br><span class="line">#tags: /tags</span><br><span class="line">Categories: /categories</span><br><span class="line">About: /about/index.html</span><br></pre></td></tr></table></figure></li><li><p>将文章分类<br>新建文章后，在开头字段添加 categories: Life，其中 Life 就是我的分类类别，相同的 categories 博客会自动将其归类到一起，而且每一个类别均会显示在页面的 Header 中；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 2018 目标</span><br><span class="line">date: 2018-01-28 15:50:35</span><br><span class="line">tags:</span><br><span class="line">categories: Life</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ul><h1 id="创建新博文"><a href="#创建新博文" class="headerlink" title="创建新博文"></a>创建新博文</h1><p>使用 <code>hexo new [layout] &lt;title&gt;</code> 命令来生成一篇文章，如果 <code>layout</code> 没有指明的话，hexo 会使用<code>_config.yml</code>中 <code>default_layout</code> 的默认配置（通常情况下就是<code>post</code>）。如果 <code>title</code>包含空格的话，需要用引号括起来。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;这是我的第一篇博客&quot;</span><br></pre></td></tr></table></figure><p>这句话有几个地方需要解释一下：</p><p><code>layout</code>是什么？<code>layout</code>的意思是布局，hexo博客安装成功后，在默认的根部录下，有一个<code>scaffolds</code>文件夹，里面有个3个文件，分别是<code>draft.md</code>、 <code>page.md</code>、 <code>post.md</code>。这3个文件就是默认的 <code>layout</code> 。</p><p>如果不提供layout的话，也可以生成博客，不过默认的<code>layout</code>是在 <code>_config.yml</code> 中的配置。一般情况下，如果没有更改过任何 <code>_config.yml</code> 中的内容的话，默认的 <code>layout</code> 是 <code>post</code>。</p><p>创建完博客后，在 Markdown 文件中，在 Tag: 后填写关键词，categories 后面填写分类目录。</p><h1 id="开启统计功能"><a href="#开启统计功能" class="headerlink" title="开启统计功能"></a>开启统计功能</h1><blockquote><p>hexo 默认是带有不蒜子统计功能，只是由于其引用不蒜子的 js 脚本较早，后来因七牛的域名强制废弃，导致 hexo 内置的统计功能全部失效，其实只需要改下其引用的 Url 即可：打开 <code>themes\next\layout\_third-party\analytics\busuanzi-counter.swig</code>文件，将其中的<code>https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js</code> 改成 <code>https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js</code>，然后分别执行更新部署即可，其它操作已经不需要再手动操作了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h1 id="Url-去除中文"><a href="#Url-去除中文" class="headerlink" title="Url 去除中文"></a>Url 去除中文</h1><p>Url 中包含中文是很不利于 SEO 的，一下操作可以去除 Url 中的中文符号，并永久固定链接地址；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>然后修改站点根目录下的 _config.yml 配置文件，将 permalink 格式修改为以下内容格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># permalink: :year/:month/:day/:title/</span><br><span class="line"># permalink_defaults:</span><br><span class="line">permalink: posts/:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: hex    # 进制：dec(default) and hex</span><br></pre></td></tr></table></figure><p>最后重新部署网站即可。</p><h1 id="评论管理"><a href="#评论管理" class="headerlink" title="评论管理"></a>评论管理</h1><h2 id="开启或关闭评论"><a href="#开启或关闭评论" class="headerlink" title="开启或关闭评论"></a>开启或关闭评论</h2><p>如果有启用、或者关闭评论，默认页面也会带有评论。需要关闭的话，目前是在每一篇文章的开头添加字段 comments 并将值设置为 false（默认为开启），如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 2018 目标</span><br><span class="line">date: 2018-01-28 15:50:35</span><br><span class="line">tags:</span><br><span class="line">categories: Life</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure></p><p><strong>注：当下的这种方式比较愚，需要在每一篇文章的开头手动添加这个字段，后面再研究下如何在模板中自动将 comments 改为 false。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下编译 WebRTC</title>
      <link href="/posts/3694004066.html"/>
      <url>/posts/3694004066.html</url>
      
        <content type="html"><![CDATA[<p>– Windows 下编译 WebRTC</p><h1 id="一、系统环境准备"><a href="#一、系统环境准备" class="headerlink" title="一、系统环境准备"></a>一、系统环境准备</h1><h2 id="1、参考官方文档"><a href="#1、参考官方文档" class="headerlink" title="1、参考官方文档"></a>1、参考官方文档</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://webrtc.org/native-code/development/   //官方编译指导首页</span><br><span class="line">https://webrtc.org/native-code/development/prerequisite-sw/  //依赖工具安装指导页</span><br><span class="line">http://dev.chromium.org/developers/how-tos/install-depot-tools //用于下载代码的工具包安装指导页面</span><br></pre></td></tr></table></figure><h2 id="2、Windows-10-amp-MingW-amp-VS2015"><a href="#2、Windows-10-amp-MingW-amp-VS2015" class="headerlink" title="2、Windows 10 &amp; MingW &amp; VS2015"></a>2、Windows 10 &amp; MingW &amp; VS2015</h2><p>如果已经安装了 cygwin，则建议先将其重命名为 cygwin_bak，使其目录内的工具无效，因为 WebRTC 官方文档已经明确不推荐使用 CygWin 了，否则编译过程中可能会发生各种奇奇怪怪的错误，原文如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chromium is mostly designed to be run using the native Windows tools and the Msys (Git for Windows) toolchain. Cygwin is not recommended, and likely things will fail in cryptic ways.</span><br></pre></td></tr></table></figure><p>自行下载并安装 MingW。</p><p>自行下载安装 VS2015，因为最新的 webrtc 使用到了 C++ 11的一些新特性，如果使用 VS2013 等较旧的一些 IDE，可能会由于 对 C++ 11 支持的不够完整，而产生编译错误。</p><h2 id="3、安装-python"><a href="#3、安装-python" class="headerlink" title="3、安装 python"></a>3、安装 python</h2><p>下载并安装 python，并将其目录配置在环境变量中，一定要安装 Python 2.7 版本的，太高或者太低均会报错！</p><p>安装完成后，将 Python 所在目录添加到 PATH 环境变量中，并通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set PTATH=C:</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p><p>使环境变量生效，确认 Python 是否已经正确配置，执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where python</span><br></pre></td></tr></table></figure></p><p>如果可以有效输出 python.exe 所在目录，则配置正确。</p><h2 id="4、安装-depot-tools"><a href="#4、安装-depot-tools" class="headerlink" title="4、安装 depot_tools"></a>4、安装 depot_tools</h2><p>安装 WebRTC 代码下载工具 depot_tools（Google），参考页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://dev.chromium.org/developers/how-tos/install-depot-tools</span><br></pre></td></tr></table></figure></p><p>，Windows 下设置环境变量，需将 depot_toolss 所在目录添加到环境变量 ‘PATH’ 的最前面（目录中不要有空格），记得在标准的 cmd 中执行下 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gclient</span><br></pre></td></tr></table></figure><p>命令，首次启动，它会自动下载安装所依赖的一些工具，<strong>但切记不要在非标准的 cmd 中执行此命令，如 cmder</strong>；</p><h2 id="5、下载安装-Windows-SDK-10"><a href="#5、下载安装-Windows-SDK-10" class="headerlink" title="5、下载安装 Windows SDK 10"></a>5、下载安装 Windows SDK 10</h2><p>官方下载地址 <a href="https://developer.microsoft.com/zh-cn/windows/downloads/windows-10-sdk" target="_blank" rel="noopener">Windows10 sdk</a></p><p>并配置环境变量 WINDOWSSDKDIR 指向 SDK 安装目录，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINDOWSSDKDIR=D:\Windows Kits\10</span><br></pre></td></tr></table></figure><h2 id="6、修改系统语言"><a href="#6、修改系统语言" class="headerlink" title="6、修改系统语言"></a>6、修改系统语言</h2><p>首先更改 Windows 系统区域语言为  英语，具体方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Control Panel → System and Security → System → Advanced system settings</span><br><span class="line">中文：</span><br><span class="line">控制面板-&gt;时钟、语言和区域-&gt;区域-&gt;管理（选项卡）-&gt;更改系统区域设置； 并重启</span><br></pre></td></tr></table></figure><h2 id="7、-设置默认编译工具-IDE-版本"><a href="#7、-设置默认编译工具-IDE-版本" class="headerlink" title="7、 设置默认编译工具 IDE 版本"></a>7、 设置默认编译工具 IDE 版本</h2><p>系统环境变量中添加变量 DEPOT_TOOLS_WIN_TOOLCHAIN ，值设为 0；这个环境变量作用是告诉 deppt_tools 使用本地已安装的默认的 Visual Studio 版本去编译；否则 depot_tools 会使用 Google 内部默认的版本；</p><h2 id="8、设置环境变量，用于生成-VS-工程文件"><a href="#8、设置环境变量，用于生成-VS-工程文件" class="headerlink" title="8、设置环境变量，用于生成 VS 工程文件"></a>8、设置环境变量，用于生成 VS 工程文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set DEPOT_TOOLS_WIN_TOOLCHAIN=0</span><br><span class="line">set GYP_GENERATORS=ninja,msvs-ninja</span><br><span class="line">set GYP_MSVS_VERSION=2015</span><br></pre></td></tr></table></figure><h2 id="9、安装-DirectX-SDk"><a href="#9、安装-DirectX-SDk" class="headerlink" title="9、安装 DirectX SDk"></a>9、安装 DirectX SDk</h2><p>安装DirectX SDK June 2010，安装完成后可能会报错，错误代码“s1023”,这是因为与系统已有的visual c++ redistributable packages版本冲突，不用管它，直接退出安装程序即可。这里我们需要的只是安装目录下的头文件和库。</p><p>#二、 下载 WebRTC 源码</p><p>注：CMD 命令行窗口使用管理员权限打开；</p><h2 id="1、下载源码"><a href="#1、下载源码" class="headerlink" title="1、下载源码"></a>1、下载源码</h2><p>选定好 WebRTC 源码存放目录后，如 E:/OpenSource 目下，通过 CMD 进入此目录，依次执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir webrtc-checkout</span><br><span class="line">cd webrtc-checkout</span><br><span class="line">fetch --nohooks webrtc</span><br><span class="line">gclient sync</span><br></pre></td></tr></table></figure><p>前三条命令一次获取 WebRTC 源码，需要下载较长的时间。</p><p>如果在执行 gclient sync 命令时，发现以下错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Please follow the instructions at https://www.chromium.org/developers/how-tos/build-instructions-windows                                                                          </span><br><span class="line">***</span><br><span class="line">returned non-zero exit status 1 in E:\OpenSource\webrtc-checkout</span><br></pre></td></tr></table></figure><p>仔细查看报错信息，可以看到，命令执行失败，并建议我们先参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.chromium.org/developers/how-tos/build-instructions-windows</span><br></pre></td></tr></table></figure><p>指导页完成 Windows 下的一些编译准备工作，可能是漏掉了一些前期准备工作，主要是</p><p><strong>更改 Windows 系统区域语言为  英语</strong> </p><p>具体方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Control Panel → System and Security → System → Advanced system settings</span><br><span class="line">中文：</span><br><span class="line">控制面板-&gt;时钟、语言和区域-&gt;区域-&gt;管理（选项卡）-&gt;更改系统区域设置； 并重启</span><br></pre></td></tr></table></figure><p><strong>系统环境变量中添加变量 DEPOT_TOOLS_WIN_TOOLCHAIN ，值设为 0</strong> </p><p>这个环境变量作用是告诉 deppt_tools 使用本地已安装的默认的 Visual Studio 版本去编译；否则 depot_tools 会使用 Google 内部默认的版本；</p><p>至此环境已经彻底准备好，重新执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gclient sync</span><br></pre></td></tr></table></figure></p><p>命名执行成功！</p><h2 id="2、-可选项：指定如何跟踪处理新的分支"><a href="#2、-可选项：指定如何跟踪处理新的分支" class="headerlink" title="2、 可选项：指定如何跟踪处理新的分支"></a>2、 可选项：指定如何跟踪处理新的分支</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config branch.autosetupmerge always</span><br><span class="line">git config branch.autosetuprebase always</span><br></pre></td></tr></table></figure><p>  <strong>git config branch.autosetupmerge always</strong></p><p>  表示 自动从远程分支合并提交到本地分支，如果不做此设置，你需要手动 merge；</p><p>  <strong>git config branch.autosetuprebase always</strong></p><p>  设置在执行 git pull  命令时做 rebase 而不是是 merge；可选的值还有 never：不自动 rebase， local 跟踪本地分支进行 rebase， remote 跟踪远程分支进行 rebase， always 所有跟踪的分支都自动进行 rebase；  ​</p><h2 id="3、-可选项：创建一个新的本地分支"><a href="#3、-可选项：创建一个新的本地分支" class="headerlink" title="3、 可选项：创建一个新的本地分支"></a>3、 可选项：创建一个新的本地分支</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">git checkout master</span><br><span class="line">git new-branch your-branch-name</span><br></pre></td></tr></table></figure><p>  建议创建下新的本地开发分支，如： git new-branch dev  ​</p><ul><li><p>编译前更新下最新代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p><strong>注：</strong>如果在上一步中，没有创建新的分支，则使用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><p>命令代替，以获取最新代码。</p></li></ul><p><strong>注：</strong>由于WebRTC 目前还在频繁的更新中，建议定期的去下载更新下编译工具链及其依赖，通过执行<br>gclient sync 既可!</p><h1 id="三、编译"><a href="#三、编译" class="headerlink" title="三、编译"></a>三、编译</h1><p>WebRTC  目前使用 GN 来生成构建脚本，Ninja 进行构建，所以系统平台均是。</p><p>所以网上说的通过 GYP 生成 VS 解决方案工程文件的博文都已失效，用的均为旧版本的 webrtc。</p><h2 id="1、通过-Ninja-编译"><a href="#1、通过-Ninja-编译" class="headerlink" title="1、通过 Ninja 编译"></a>1、通过 Ninja 编译</h2><h3 id="a、-生成-Ninja-工程文件"><a href="#a、-生成-Ninja-工程文件" class="headerlink" title="a、 生成 Ninja 工程文件"></a>a、 生成 Ninja 工程文件</h3><p>Ninja 工程文件由 GN 生成，为其选择一个放置的目录中，如 out/Debug 或者 out/Release，这里官方建议选择 out/Default 这样可以放置 debug 和 release，在 src 目录下还行一下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn gen out/Default</span><br></pre></td></tr></table></figure><p>如果 提示 gn 命令 not found，需检查 depot_tools 环境变量设置是否生效。</p><p>执行以下命令生成 Ninja 工程文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn gen out/Default</span><br></pre></td></tr></table></figure><p>如果需要生成 release 工程文件，需在后面加上关闭 debug 的参数  <strong>–args=is_debug= false</strong></p><p>如果需要清理 Ninja 工程文件，但保持 GN 环境配置不变的话，可以执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn clean out/Default</span><br></pre></td></tr></table></figure><h3 id="b、通过-Ninja-命令编译"><a href="#b、通过-Ninja-命令编译" class="headerlink" title="b、通过 Ninja 命令编译"></a>b、通过 Ninja 命令编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja -C out/Default</span><br></pre></td></tr></table></figure><h2 id="2、通过-VS-IDE-编译"><a href="#2、通过-VS-IDE-编译" class="headerlink" title="2、通过 VS IDE 编译"></a>2、通过 VS IDE 编译</h2><p>除了 ninja 外，其他的构建系统不受支持(可能会失败)，比如Windows上的Visual Studio或者OSX上的Xcode。GN支持一种混合使用的方法，即由 Visual studio/xcode 用于编辑和驱动编译。</p><p>官方原文如下：</p><p>Other build systems are <strong>not supported</strong> (and may fail), such as Visual Studio on Windows or Xcode on OSX. GN supports a hybrid approach of using <a href="https://ninja-build.org/" target="_blank" rel="noopener">Ninja</a> for building, but Visual Studio/Xcode for editing and driving compilation.</p><h3 id="a、生成-VS-解决方案工程文件"><a href="#a、生成-VS-解决方案工程文件" class="headerlink" title="a、生成 VS 解决方案工程文件"></a>a、生成 VS 解决方案工程文件</h3><p>src 目录下执行以下命令（默认生成 Debug ）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn gen --ide=vs out/Debug</span><br></pre></td></tr></table></figure></p><p>会在 out/VS 目录下生成 all.sln 解决方案文件；如果需要生成 release 工程文件，需在后面加上关闭 debug 的参数  <strong>–args=’is_debug= false’</strong><br>即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn gen --ide=vs out/Release --args=is_debug= false</span><br></pre></td></tr></table></figure></p><h3 id="b、打开-all-sln-文件编译"><a href="#b、打开-all-sln-文件编译" class="headerlink" title="b、打开 all.sln 文件编译"></a>b、打开 all.sln 文件编译</h3>]]></content>
      
      
      <categories>
          
          <category> RTC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>janus 服务器搭建</title>
      <link href="/posts/1195716763.html"/>
      <url>/posts/1195716763.html</url>
      
        <content type="html"><![CDATA[<p>－－Ubuntu 下 Janus Server 搭建笔记</p><h1 id="一-、简介"><a href="#一-、简介" class="headerlink" title="一 、简介"></a>一 、简介</h1><p><a href="https://janus.conf.meetecho.com/index.html" target="_blank" rel="noopener">Janus</a> 是一个开源的，通过 C 语言实现了对 WebRTC 支持的 Gateway；Janus 自身实现得很简单，提供插件机制来支持不同的业务逻辑，配合官方自带插件就可以用来实现高效的 Media Server 服务。</p><p>本文主要介绍如何在 Ubuntu 16.04 下搭建起 janus 服务器，实现 janus 官方 Demo 浏览器与 Android APP Demo（janus-gateway-android）之间的音视频通话。</p><p>效果图如下：</p><p><img src="/images/Janus服务器搭建/brower-android-test.png" alt=""></p><p>Janus 官网：<a href="https://janus.conf.meetecho.com/index.html" target="_blank" rel="noopener">https://janus.conf.meetecho.com/index.html</a></p><p>参考文档：<a href="https://github.com/meetecho/janus-gateway" target="_blank" rel="noopener">https://github.com/meetecho/janus-gateway</a></p><h1 id="二、-下载编译-Janus"><a href="#二、-下载编译-Janus" class="headerlink" title="二、 下载编译 Janus"></a>二、 下载编译 Janus</h1><p>编译运行 Janus Server 需要依赖较多的一些第三方库，而这些依赖库在 Ubuntu 下主要通过 aptitude 进行安装，首先通过安装 aptitude：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install aptitude</span><br></pre></td></tr></table></figure><h2 id="1、-安装依赖"><a href="#1、-安装依赖" class="headerlink" title="1、 安装依赖"></a>1、 安装依赖</h2><p>Ubuntu 下通过 aptitude 批量安装依赖工具包，这里建议 Ubuntu 镜像源（/etc/apt/source.list）不要为了追求速度而改用了国内的某些镜像源，如 网易 163，这可能会导致某些工具包下载失败，建议依然使用官方自带的镜像源。</p><p>批量安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo aptitude install libmicrohttpd-dev libjansson-dev libnice-dev \</span><br><span class="line">libssl-dev libsrtp-dev libsofia-sip-ua-dev libglib2.0-dev \</span><br><span class="line">libopus-dev libogg-dev libcurl4-openssl-dev pkg-config gengetopt \</span><br><span class="line">libtool automake</span><br></pre></td></tr></table></figure><p>如果出现某个工具包下载失败，请修改镜像源为官方地址，并执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p>以更新镜像源，完成后重新安装。</p><h2 id="2、-安装-WebSocket"><a href="#2、-安装-WebSocket" class="headerlink" title="2、 安装 WebSocket"></a>2、 安装 WebSocket</h2><p>janus 支持 WebSocket 是可选项，如果不安装，编译 janus 时，默认不支持 WebSocket 的链接请求，而 Android APP Demo 是通过 WebSocket 与 janus 进行通信的，因为我们希望 Android APP Demo 能与浏览器（HTTP）进行视频通话，所以就必须要在编译 janus 时支持 WebSocket。</p><p>依次执行以下命令，分别进行下载，编译，安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/warmcat/libwebsockets.git</span><br><span class="line">cd libwebsockets</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX:PATH=/usr -DCMAKE_C_FLAGS=&quot;-fpic&quot; ..</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>安装成功后，在编译 janus 时，janus 默认会增加对 WebSocket 的集成，或者通过增加编译参数 –enable-websockets 打开 WebSocket 开关，或 –disable-websockets 关闭 WebSocket 开关。</p><h2 id="3、-安装-Http-Server"><a href="#3、-安装-Http-Server" class="headerlink" title="3、 安装 Http Server"></a>3、 安装 Http Server</h2><p>Janus 源码目录下的 html 下自带 Web Demo（html &amp; JavaScript ），Janus 编译完成并 Start 以后，需要通过 http server 访问 Janus Web Demo，其中包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Echo Test:             yes</span><br><span class="line">Streaming:             yes</span><br><span class="line">Video Call:            yes</span><br><span class="line">SIP Gateway:           yes</span><br><span class="line">Audio Bridge:          yes</span><br><span class="line">Video Room:            yes</span><br><span class="line">Voice Mail:            yes</span><br><span class="line">Record&amp;Play:           yes</span><br><span class="line">Text Room:             yes</span><br></pre></td></tr></table></figure><p>以上 janus 插件均可通过相应的 http 链接进行访问体验。​        </p><p>以下介绍一种快速，便捷，轻巧的 HTTP Server 安装方式：</p><p>通过 Node.js (基于 Chrome V8 引擎的 JavaScript 运行环境) 进行安装，首先安装 Node.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br></pre></td></tr></table></figure><p>安装成功后，通过 npm (npm 是 Node.js 的包管理器，是全球最大的开源库生态系统) 进行安装 httpserver：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm -g install http-server</span><br></pre></td></tr></table></figure><p>启动方式：</p><p>进入到 html 目录，执行 http-server 命令即可，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gobert@gobert-ThinkPad-X230:~/OpenSource/janus-gateway$ cd html/</span><br><span class="line">gobert@gobert-ThinkPad-X230:~/OpenSource/janus-gateway/html$ http-server </span><br><span class="line">Starting up http-server, serving ./</span><br><span class="line">Available on:</span><br><span class="line">  http://127.0.0.1:8080</span><br><span class="line">  http://100.100.32.64:8080</span><br><span class="line">Hit CTRL-C to stop the server</span><br></pre></td></tr></table></figure><p>输入 http url 即可访问。</p><p><strong>注：需首先 build &amp; start janus Server！</strong></p><h2 id="4、-安装-libsrtp"><a href="#4、-安装-libsrtp" class="headerlink" title="4、 安装 libsrtp"></a>4、 安装 libsrtp</h2><p>Janus 需要至少 version 1.5 以上的 libsrtp，如果系统中已经安装了 libsrtp，则首先卸载后，手动安装新版本，这里我们安装 libsrtp 2.0，依次执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/cisco/libsrtp/archive/v2.0.0.tar.gz</span><br><span class="line">tar xfv v2.0.0.tar.gz</span><br><span class="line">cd libsrtp-2.0.0</span><br><span class="line">./configure --prefix=/usr --enable-openssl</span><br><span class="line">make shared_library &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><h2 id="5、-编译-Janus"><a href="#5、-编译-Janus" class="headerlink" title="5、 编译 Janus"></a>5、 编译 Janus</h2><p>通过 Git 下载 Janus 源码，并编译安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/meetecho/janus-gateway.git</span><br><span class="line">sh autogen.sh</span><br><span class="line">./configure --prefix=/opt/janus --enable-websockets --enable-docs</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>configure 执行成功后，会输出 janus 所支持的 协议及插件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">libsrtp version:           2.0.x</span><br><span class="line">SSL/crypto library:        OpenSSL</span><br><span class="line">DTLS set-timeout:          not available</span><br><span class="line">DataChannels support:      no</span><br><span class="line">Recordings post-processor: no</span><br><span class="line">TURN REST API client:      yes</span><br><span class="line">Doxygen documentation:     no</span><br><span class="line">Transports:</span><br><span class="line">    REST (HTTP/HTTPS):     yes                //支持 HTTP 访问</span><br><span class="line">    WebSockets:            yes (new API)  //支持 WebSocket 访问</span><br><span class="line">    RabbitMQ:              no</span><br><span class="line">    MQTT:                  no</span><br><span class="line">    Unix Sockets:          yes</span><br><span class="line">Plugins:</span><br><span class="line">    Echo Test:             yes</span><br><span class="line">    Streaming:             yes</span><br><span class="line">    Video Call:            yes</span><br><span class="line">    SIP Gateway:           yes</span><br><span class="line">    Audio Bridge:          yes</span><br><span class="line">    Video Room:            yes</span><br><span class="line">    Voice Mail:            yes</span><br><span class="line">    Record&amp;Play:           yes</span><br><span class="line">    Text Room:             yes</span><br><span class="line">Event handlers:</span><br><span class="line">    Sample event handler:  yes</span><br></pre></td></tr></table></figure><h2 id="6、-运行-Janus"><a href="#6、-运行-Janus" class="headerlink" title="6、 运行 Janus"></a>6、 运行 Janus</h2><p>如果全部安装以上步骤进行编译的 janus ，那么 janus 的全局配置文件存放目录为 ： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/janus/etc/janus/janus.cfg</span><br></pre></td></tr></table></figure><p>或者在启动 janus 时，加上相应的启动参数，参数可通过 janus –help 查看；</p><p>janus 默认的配置中是没有 WebSocket 的配置的，直接启动 Janus 会因没有 WebSocket 配置文件而报错。幸运的是在配置目录中 Janus 已经给我们提供了一个 WebSocket 的示例配置文件 ： janus.transport.websockets.cfg.sample，（如果我们要通过 WebSocket 连接 Janus，则需要有个 WebSocket 的配置文件）这里我们可以直接拷贝这个示例文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp janus.transport.websockets.cfg.sample janus.transport.websockets.cfg</span><br></pre></td></tr></table></figure><p>通过查看此配置文件，可以得知 Janus 默认的 WebSocket 的端口号为 8188，<strong>记住这个端口号，在 Android APP Demo 中会使用到！</strong></p><p>启动 Janus：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/janus/bin/janus --debug-level=7 --log-file=$HOME/janus-log</span><br></pre></td></tr></table></figure><p>根据需要可以选择是否加上后面两个启动参数。</p><h1 id="三、-视频通话联调测试"><a href="#三、-视频通话联调测试" class="headerlink" title="三、 视频通话联调测试"></a>三、 视频通话联调测试</h1><p>我们使用 PC 下的 浏览器 与 Android APP Demo 进行联调。</p><h2 id="1、-启动-Web-Demo"><a href="#1、-启动-Web-Demo" class="headerlink" title="1、 启动 Web Demo"></a>1、 启动 Web Demo</h2><p>进入到 janus 目录下的 html 目录，启动 http-server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gobert@gobert-ThinkPad-X230:~$ cd ~/OpenSource/janus-gateway/html/</span><br><span class="line">gobert@gobert-ThinkPad-X230:~/OpenSource/janus-gateway/html$ http-server </span><br><span class="line">Starting up http-server, serving ./</span><br><span class="line">Available on:</span><br><span class="line">  http://127.0.0.1:8080</span><br><span class="line">  http://100.100.32.64:8080</span><br><span class="line">Hit CTRL-C to stop the server</span><br></pre></td></tr></table></figure><p>这样外部便可以通过 <a href="http://100.100.32.64:8080" target="_blank" rel="noopener">http://100.100.32.64:8080</a> 进行访问了，进入首页后，找到 videoRoom，Start</p><h2 id="2、-启动-Android-APP-Demo"><a href="#2、-启动-Android-APP-Demo" class="headerlink" title="2、 启动 Android APP Demo"></a>2、 启动 Android APP Demo</h2><ul><li>下载:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:Computician/janus-gateway-android.git</span><br></pre></td></tr></table></figure><ul><li><p>修改源代码</p><p>janus-gateway-android 支持两个 Demo 测试：EchoTest 和 VideoRoom，默认情况下会启用 EchoTest，这个 Demo 仅仅是连接服务器后，将数据再发回本地进行本地测试，我们要改为与房间内的其它用户（浏览器）进行视频通话，则需要启用另外一个测试用例 VideoRoom，按照如下方式修改代码：</p><p>JanusActivity.java 类中新增 VideoRenderer.Callbacks 数组（视频房间中可能会有多人）,暂定义为 2 个，实际连接人数不要超过此数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private VideoRenderer.Callbacks remoteRenders[] = new VideoRenderer.Callbacks[1];</span><br></pre></td></tr></table></figure><p>OnCreate 方法中初始化以上定义的数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remoteRenders[0] = VideoRendererGui.create(0, 0, 25, 25, VideoRendererGui.ScalingType.SCALE_ASPECT_FILL, true);</span><br></pre></td></tr></table></figure><p>APP Demo 是通过 WebSocket 连接 Janus Server，所以修改 VideoRoomTest.java 中 JANUS_URL 地址为我们启动的 Janus 服务器 WebSocket 地址，IP 为 janus server 地址，端口默认为 8188：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final String JANUS_URI = &quot;ws://100.100.32.64:8188&quot;;</span><br></pre></td></tr></table></figure></li><li><p>编译安装</p><p>通过 Android studio 进行编译安装到 Android 机。</p></li></ul><h2 id="3、联调测试"><a href="#3、联调测试" class="headerlink" title="3、联调测试"></a>3、联调测试</h2><p>Janus Server 默认会开启两个视频房间：1234 和 5678，分别使用 VP8 和 VP9 视频编码器，所以我们通过 Brower 和 Android APP Demo 进行联调测试时，暂不需要设置房间 ID。</p><p>效果图：</p><p><img src="/images/Janus服务器搭建/brower-android-test.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> RTC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2018 目标</title>
      <link href="/posts/2738500025.html"/>
      <url>/posts/2738500025.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/2018.png" alt=""></p><p>给自己制定一个 2018 的目标</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><ul><li>阅读 5 本专业以外的书籍</li><li>研读 java 核心技术卷1 和 卷2，以及 Android 的三本书籍，突破单平台开发的天花板，开发并上线一个自己的 Android App</li><li>将京东上已购的情商方面的书籍读完</li><li>再次研读一遍 《Go 并发编程》</li><li>在线阅读 C++11、C++14、C++17 新标准，并精通</li></ul><h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><ul><li>完全吃透 webrtc native 源码，并输出源码分析相关的博客</li></ul><h2 id="财务目标"><a href="#财务目标" class="headerlink" title="财务目标"></a>财务目标</h2><ul><li>突破只有工资的这一种收入来源局限，创造一种工资之外的收入来源，为实现财务自由走出第一步</li></ul>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
